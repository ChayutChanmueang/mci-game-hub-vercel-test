<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zoo Brain Training</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600;800&family=Fredoka:wght@600&family=Kanit:wght@400;600&display=swap"
        rel="stylesheet">

    <style>
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #0f172a;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #root {
            width: 100%;
            height: 100vh;
            background-color: #f0fdf4;
            /* Light Green Bg */
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 500px) {
            #root {
                max-width: 414px;
                max-height: 896px;
                height: 90vh;
                border-radius: 40px;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
                border: 8px solid #14532d;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes popIn {
            0% {
                transform: scale(0.9);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse-custom {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @keyframes bounce-slow {

            0%,
            100% {
                transform: translateY(-5%);
            }

            50% {
                transform: translateY(5%);
            }
        }

        @keyframes pulse-dot {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }

            70% {
                transform: translate(-50%, -50%) scale(1.3);
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        @keyframes moveBelt {
            0% {
                top: -10%;
            }

            100% {
                top: 100%;
            }
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-10px);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 0;
            }

            20% {
                transform: translateY(-20px) scale(1.1);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) scale(1);
                opacity: 0;
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out;
        }

        .animate-slide-up {
            animation: slideUp 0.4s ease-out forwards;
        }

        .animate-pop-in {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .animate-pulse-custom {
            animation: pulse-custom 2s infinite;
        }

        .animate-bounce-slow {
            animation: bounce-slow 3s infinite ease-in-out;
        }

        .animate-pulse-dot {
            animation: pulse-dot 2s infinite;
        }

        .animate-move-belt {
            animation: moveBelt 3s linear infinite;
        }

        .animate-bounce-animal {
            animation: bounce 0.6s infinite alternate;
        }

        .animate-shake {
            animation: shake 0.5s;
        }

        .animate-float-up {
            animation: floatUp 0.8s forwards;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Common UI Classes */
        .btn-primary {
            @apply bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-2xl shadow-lg transition-all active:scale-95 flex items-center justify-center gap-2;
        }

        .btn-secondary {
            @apply bg-white border-2 border-emerald-100 text-emerald-700 font-bold py-3 px-6 rounded-2xl shadow-sm transition-all active:scale-95 flex items-center justify-center gap-2;
        }

        .card {
            @apply bg-white rounded-3xl shadow-sm border border-emerald-100 p-4;
        }

        .font-fredoka {
            font-family: 'Fredoka', sans-serif;
        }

        /* Attention Game Specifics */
        .game-bg-dark {
            background-color: #111;
            background-image: radial-gradient(#333 2px, transparent 2px);
            background-size: 30px 30px;
        }

        .belt {
            position: absolute;
            top: -5%;
            height: 85%;
            background: #64748b;
            border-left: 3px solid rgba(0, 0, 0, 0.1);
            border-right: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 0 0 20px 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .belt-marking {
            position: absolute;
            width: 100%;
            height: 2%;
            background: rgba(255, 255, 255, 0.1);
        }

        .animal-slot {
            position: absolute;
            bottom: 80px;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 30%;
        }

        .animal-emoji {
            font-size: 4.5rem;
            line-height: 1;
            filter: drop-shadow(0 8px 12px rgba(0, 0, 0, 0.15));
            transition: transform 0.2s;
            z-index: 20;
            cursor: pointer;
        }

        .animal-diet-bubble {
            background: white;
            color: #334155;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'Fredoka', sans-serif;
            margin-bottom: -5px;
            z-index: 25;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 2px solid #f1f5f9;
            transform: scale(0.95);
        }

        .food-item {
            position: absolute;
            width: 60px;
            height: 60px;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            z-index: 30;
            cursor: pointer;
            user-select: none;
            filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.1));
            touch-action: manipulation;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- GLOBAL CONSTANTS ---
        const MAX_LEVEL = 15;
        const GAMES = {
            memory: { id: 'memory', name: 'Memory', icon: 'üß†', desc: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥', color: 'bg-orange-100 text-orange-600' },
            visuospatial: { id: 'visuospatial', name: 'Visuospatial', icon: 'üìê', desc: '‡∏°‡∏¥‡∏ï‡∏¥‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå', color: 'bg-blue-100 text-blue-600' },
            attention: { id: 'attention', name: 'Attention', icon: '‚ö°', desc: '‡∏™‡∏°‡∏≤‡∏ò‡∏¥', color: 'bg-yellow-100 text-yellow-600' },
            language: { id: 'language', name: 'Language', icon: 'üó£Ô∏è', desc: '‡∏†‡∏≤‡∏©‡∏≤', color: 'bg-purple-100 text-purple-600' },
            executive: { id: 'executive', name: 'Executive', icon: 'üß©', desc: '‡∏Å‡∏≤‡∏£‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£', color: 'bg-rose-100 text-rose-600' }
        };

        // --- ICONS ---
        const Icon = ({ path, size = 24, className = "", viewBox = "0 0 24 24", fill = "none", stroke = "currentColor" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox={viewBox} fill={fill} stroke={stroke} strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {path}
            </svg>
        );
        const Icons = {
            Play: <polygon points="5 3 19 12 5 21 5 3"></polygon>,
            Home: <><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" /><polyline points="9 22 9 12 15 12 15 22" /></>,
            Refresh: <><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" /><path d="M16 21h5v-5" /></>,
            Trash: <><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></>,
            Check: <polyline points="20 6 9 17 4 12"></polyline>,
            Lock: <><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></>,
            Logout: <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>,
            Heart: <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>,
            Trophy: <><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" /><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" /><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z" /></>,
            Clock: <><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></>,
            ChevronRight: <path d="m9 18 6-6-6-6" />,
            Star: <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" />,
            ArrowLeft: <><line x1="19" y1="12" x2="5" y2="12" /><polyline points="12 19 5 12 12 5" /></>,
            Pause: <><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></>,
            X: <><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>,
            RotateCcw: <><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5"></path></>,
            Grid4: <><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></>
        };

        // ==========================================
        // GAME 1: MEMORY
        // ==========================================
        function MemoryGame({ level, onComplete, onExit }) {
            const MEMORY_ITEMS = [
                { id: 'lion', name: '‡∏™‡∏¥‡∏á‡πÇ‡∏ï', icon: 'ü¶Å' }, { id: 'elephant', name: '‡∏ä‡πâ‡∏≤‡∏á', icon: 'üêò' },
                { id: 'monkey', name: '‡∏•‡∏¥‡∏á', icon: 'üêµ' }, { id: 'penguin', name: '‡πÄ‡∏û‡∏ô‡∏Å‡∏ß‡∏¥‡∏ô', icon: 'üêß' },
                { id: 'giraffe', name: '‡∏¢‡∏µ‡∏£‡∏≤‡∏ü', icon: 'ü¶í' }, { id: 'zebra', name: '‡∏°‡πâ‡∏≤‡∏•‡∏≤‡∏¢', icon: 'ü¶ì' },
                { id: 'panda', name: '‡πÅ‡∏û‡∏ô‡∏î‡πâ‡∏≤', icon: 'üêº' }, { id: 'tiger', name: '‡πÄ‡∏™‡∏∑‡∏≠', icon: 'üêØ' },
                { id: 'koala', name: '‡πÇ‡∏Ñ‡∏≠‡∏≤‡∏•‡πà‡∏≤', icon: 'üê®' }, { id: 'cow', name: '‡∏ß‡∏±‡∏ß', icon: 'üêÆ' },
                { id: 'pig', name: '‡∏´‡∏°‡∏π', icon: 'üê∑' }, { id: 'frog', name: '‡∏Å‡∏ö', icon: 'üê∏' },
            ];

            const TOTAL_ROUNDS = 15;
            const [step, setStep] = useState('memorize');
            const [target, setTarget] = useState(null);
            const [distractCount, setDistractCount] = useState(0);
            const [options, setOptions] = useState([]);
            const [currentRound, setCurrentRound] = useState(1);

            // Level Scaling (Cap difficulty at 15)
            const effectiveLevel = Math.min(level, 15);
            const distractQCount = effectiveLevel <= 5 ? 1 : (effectiveLevel <= 10 ? 2 : 3);
            const recallOptionCount = effectiveLevel <= 5 ? 3 : (effectiveLevel <= 10 ? 4 : 6);

            useEffect(() => {
                startRound();
            }, []);

            const startRound = () => {
                const item = MEMORY_ITEMS[Math.floor(Math.random() * MEMORY_ITEMS.length)];
                setTarget(item);
                setStep('memorize');
                setDistractCount(0);
            };

            const handleMemorized = () => {
                setStep('distract');
            };

            const handleDistractAnswer = () => {
                if (distractCount + 1 < distractQCount) {
                    setDistractCount(prev => prev + 1);
                } else {
                    const others = MEMORY_ITEMS.filter(i => i.id !== target.id).sort(() => 0.5 - Math.random()).slice(0, recallOptionCount - 1);
                    setOptions([target, ...others].sort(() => 0.5 - Math.random()));
                    setStep('recall');
                }
            };

            const handleRecall = (selected) => {
                if (selected.id === target.id) {
                    if (currentRound < TOTAL_ROUNDS) {
                        setCurrentRound(p => p + 1);
                        startRound();
                    } else {
                        onComplete();
                    }
                } else {
                    alert('‡∏ú‡∏¥‡∏î‡∏Ñ‡∏£‡∏±‡∏ö ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
                    startRound();
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center justify-center p-6 bg-orange-50 h-full relative">
                    <div className="absolute top-4 right-4 bg-orange-200 text-orange-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Round {currentRound}/{TOTAL_ROUNDS}</div>

                    {step === 'memorize' && (
                        <div className="text-center animate-pop-in">
                            <h2 className="text-2xl font-bold mb-6 text-orange-800">‡∏à‡∏≥‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ</h2>
                            <div className="text-9xl mb-6">{target?.icon}</div>
                            <div className="text-3xl font-bold mb-8 text-slate-700">{target?.name}</div>
                            <button onClick={handleMemorized} className="btn-primary w-full max-w-xs mx-auto">‡∏à‡∏≥‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß!</button>
                        </div>
                    )}

                    {step === 'distract' && (
                        <div className="text-center w-full max-w-xs animate-fade-in">
                            <h2 className="text-xl font-bold mb-4 text-orange-800">‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Ñ‡∏±‡πà‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ ({distractCount + 1}/{distractQCount})</h2>
                            <div className="bg-white p-6 rounded-2xl shadow-sm mb-4">
                                <p className="text-lg">1 + 1 ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö?</p>
                            </div>
                            <div className="grid grid-cols-2 gap-3">
                                <button onClick={handleDistractAnswer} className="py-4 bg-white rounded-xl shadow-sm font-bold text-xl hover:bg-orange-100">2</button>
                                <button onClick={() => alert('‡∏ú‡∏¥‡∏î‡∏Ñ‡∏£‡∏±‡∏ö')} className="py-4 bg-white rounded-xl shadow-sm font-bold text-xl hover:bg-orange-100">3</button>
                            </div>
                        </div>
                    )}

                    {step === 'recall' && (
                        <div className="text-center w-full animate-slide-up">
                            <h2 className="text-xl font-bold mb-6 text-orange-800">‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô?</h2>
                            <div className="grid grid-cols-2 gap-4">
                                {options.map(item => (
                                    <button key={item.id} onClick={() => handleRecall(item)} className="bg-white p-4 rounded-2xl shadow-sm flex flex-col items-center hover:bg-orange-50 active:scale-95 transition">
                                        <span className="text-5xl mb-2">{item.icon}</span>
                                        <span className="font-bold text-slate-700">{item.name}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // ==========================================
        // GAME 2: VISUOSPATIAL
        // ==========================================
        function VisuospatialGame({ level, onComplete, onExit }) {
            const [grid, setGrid] = useState([]);
            const [size, setSize] = useState(4);
            const [symmetryType, setSymmetryType] = useState('vertical');
            const [stage, setStage] = useState(1);
            const TOTAL_STAGES = 15;

            // Level Scaling (Cap at 15)
            const effectiveLevel = Math.min(level, 15);

            useEffect(() => {
                const newSize = effectiveLevel <= 5 ? 4 : (effectiveLevel <= 10 ? 5 : 6);
                const count = Math.min(3 + Math.floor(effectiveLevel / 3), 8);
                setSize(newSize);
                generateLevel(newSize, count);
            }, [level, stage]);

            const generateLevel = useCallback(() => {
                let s = 4;
                let sym = 'vertical';
                let targetDots = 3;

                const difficultyFactor = level + Math.floor(stage / 3);

                if (difficultyFactor <= 5) {
                    s = 4;
                    sym = Math.random() > 0.5 ? 'vertical' : 'horizontal';
                    targetDots = 2 + Math.floor(difficultyFactor / 3);
                } else if (difficultyFactor <= 15) {
                    s = 4;
                    const types = ['vertical', 'horizontal', 'rotational-180'];
                    sym = types[Math.floor(Math.random() * types.length)];
                    targetDots = 4;
                } else {
                    s = Math.random() > 0.6 ? 6 : 4;
                    const types = ['vertical', 'horizontal', 'rotational-180', 'quadruple'];
                    sym = types[Math.floor(Math.random() * types.length)];
                    targetDots = Math.min(5 + Math.floor((difficultyFactor - 15) / 5), 8);
                }

                if (sym === 'quadruple') targetDots = Math.min(targetDots, Math.floor((s * s) / 4) - 1);
                else targetDots = Math.min(targetDots, Math.floor((s * s) / 2) - 1);

                setSize(s);
                setSymmetryType(sym);
                isProcessingWin.current = false;

                const newGrid = Array(s * s).fill(null).map((_, i) => ({
                    id: i,
                    row: Math.floor(i / s),
                    col: i % s,
                    isSource: false,
                    filled: false,
                    locked: false,
                }));

                const isValidSource = (r, c, type) => {
                    const half = s / 2;
                    if (type === 'vertical') return c < half;
                    if (type === 'horizontal') return r < half;
                    if (type === 'rotational-180') return r < half;
                    if (type === 'quadruple') return r < half && c < half;
                    return true;
                };

                let filledCount = 0;
                let attempts = 0;
                while (filledCount < targetDots && attempts < 200) {
                    attempts++;
                    const r = Math.floor(Math.random() * s);
                    const c = Math.floor(Math.random() * s);

                    if (isValidSource(r, c, sym)) {
                        const idx = r * s + c;
                        if (!newGrid[idx].locked) {
                            newGrid[idx].locked = true;
                            newGrid[idx].isSource = true;
                            filledCount++;
                        }
                    }
                }
                setGrid(newGrid);
            }, [level, stage]);

            const getReflection = (r, c, s, type) => {
                if (type === 'vertical') return [{ r: r, c: s - 1 - c }];
                if (type === 'horizontal') return [{ r: s - 1 - r, c: c }];
                if (type === 'rotational-180') return [{ r: s - 1 - r, c: s - 1 - c }];
                if (type === 'quadruple') {
                    return [
                        { r: r, c: s - 1 - c },
                        { r: s - 1 - r, c: c },
                        { r: s - 1 - r, c: s - 1 - c }
                    ];
                }
                return [];
            };

            const isProcessingWin = useRef(false);

            const handleCellClick = (idx) => {
                if (isProcessingWin.current) return;
                const cell = grid[idx];
                if (cell.locked) return;

                const newGrid = [...grid];
                newGrid[idx].filled = !newGrid[idx].filled;
                setGrid(newGrid);
                checkWinCondition(newGrid);
            };

            const checkWinCondition = (currentGrid) => {
                if (isProcessingWin.current) return;

                const idealGrid = Array(size * size).fill(false);

                currentGrid.forEach(cell => {
                    if (cell.locked) {
                        idealGrid[cell.id] = true;
                        const reflections = getReflection(cell.row, cell.col, size, symmetryType);
                        reflections.forEach(ref => {
                            const refIdx = ref.r * size + ref.c;
                            if (refIdx >= 0 && refIdx < idealGrid.length) idealGrid[refIdx] = true;
                        });
                    }
                });

                let isComplete = true;
                for (let i = 0; i < size * size; i++) {
                    const isFilled = currentGrid[i].locked || currentGrid[i].filled;
                    if (isFilled !== idealGrid[i]) {
                        isComplete = false;
                        break;
                    }
                }

                if (isComplete) {
                    isProcessingWin.current = true;
                    setTimeout(() => {
                        if (stage < TOTAL_STAGES) {
                            setStage(s => s + 1);
                        } else {
                            onComplete();
                        }
                    }, 300);
                }
            };

            const renderAxis = () => {
                const styleLine = "absolute bg-blue-400 opacity-50 pointer-events-none z-10 shadow-sm";
                const styleDot = "absolute bg-blue-500 rounded-full z-20 pointer-events-none transform -translate-x-1/2 -translate-y-1/2 shadow-md border-2 border-white animate-pulse-dot";

                switch (symmetryType) {
                    case 'vertical': return <div className={`${styleLine} left-1/2 top-0 bottom-0 w-1 -ml-0.5`} />;
                    case 'horizontal': return <div className={`${styleLine} top-1/2 left-0 right-0 h-1 -mt-0.5`} />;
                    case 'rotational-180': return <div className={`${styleDot} top-1/2 left-1/2 w-4 h-4`} />;
                    case 'quadruple': return (
                        <>
                            <div className={`${styleLine} left-1/2 top-0 bottom-0 w-1 -ml-0.5`} />
                            <div className={`${styleLine} top-1/2 left-0 right-0 h-1 -mt-0.5`} />
                        </>
                    );
                    default: return null;
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center justify-center p-6 bg-blue-50 h-full relative font-kanit">
                    <div className="absolute top-4 right-4 bg-blue-200 text-blue-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Stage {stage}/{TOTAL_STAGES}</div>

                    <div className="mb-6 px-4 py-2 rounded-full bg-white/60 backdrop-blur-md shadow-sm border border-white/50 text-sm font-bold text-slate-600 flex items-center gap-2">
                        {symmetryType === 'rotational-180' ? <Icon path={Icons.Refresh} size={14} /> : (symmetryType === 'quadruple' ? <Icon path={Icons.Grid4} size={14} /> : <div className="w-2 h-2 rounded-full bg-blue-500"></div>)}
                        <span>
                            {symmetryType === 'vertical' && "‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á"}
                            {symmetryType === 'horizontal' && "‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô"}
                            {symmetryType === 'rotational-180' && "‡∏™‡∏°‡∏°‡∏≤‡∏ï‡∏£ 180¬∞"}
                            {symmetryType === 'quadruple' && "‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô 4 ‡∏ó‡∏¥‡∏®"}
                        </span>
                    </div>

                    <div className="relative bg-white p-3 rounded-[2rem] shadow-xl border-4 border-white transition-all duration-300">
                        {renderAxis()}
                        <div className="grid gap-2 transition-all duration-300" style={{
                            gridTemplateColumns: `repeat(${size}, 1fr)`,
                            width: 'min(80vw, 340px)',
                            height: 'min(80vw, 340px)'
                        }}>
                            {grid.map((cell) => (
                                <button key={cell.id}
                                    onClick={() => handleCellClick(cell.id)}
                                    disabled={cell.locked}
                                    className={`relative rounded-xl transition-all duration-200 transform flex items-center justify-center
                                        ${cell.locked
                                            ? 'bg-slate-300 scale-95 shadow-inner'
                                            : (cell.filled
                                                ? 'bg-blue-500 scale-100 shadow-md text-white'
                                                : 'bg-slate-100 hover:bg-slate-200 active:scale-95')
                                        }`}
                                >
                                    {cell.locked && <div className="w-3 h-3 bg-white/30 rounded-full"></div>}
                                </button>
                            ))}
                        </div>
                    </div>

                    <button onClick={generateLevel} className="mt-8 flex items-center gap-2 text-slate-400 text-sm font-bold hover:text-blue-500 transition-colors">
                        <Icon path={Icons.RotateCcw} size={16} /> ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
                    </button>
                </div>
            );
        }

        // ==========================================
        // GAME 3: ATTENTION (New Zoo Feeder Logic)
        // ==========================================
        function AttentionGame({ level, onComplete, onExit }) {
            const ANIMALS = [
                { emoji: 'ü¶Å', type: 'carn', name: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠', icon: 'ü•©' },
                { emoji: 'üêØ', type: 'carn', name: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠', icon: 'üçó' },
                { emoji: 'üêä', type: 'carn', name: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠', icon: 'üêü' },
                { emoji: 'üêò', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'üåø' },
                { emoji: 'ü¶í', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'üçÉ' },
                { emoji: 'üêá', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'ü•ï' },
                { emoji: 'ü¶ç', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'üçå' }
            ];

            const FOOD_TYPES = {
                HERB: ['üåø', 'üçé', 'ü•ï', 'ü•¨', 'üåΩ', 'üçâ', 'üçå'],
                CARN: ['ü•©', 'üçó', 'ü•ì', 'üêü', 'üçñ', 'ü¶ê'],
                TRASH: ['üëü', 'üí£', 'ü•´', 'üß±', 'üß§', 'üì¶']
            };

            const BELT_POSITIONS = { 1: [50], 2: [30, 70], 3: [20, 50, 80] };

            // Progression Constants
            const POINTS_PER_LEVEL = 100;
            const POINTS_PER_ANIMAL_CHANGE = 500;

            // State
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [beltCount, setBeltCount] = useState(1);
            const [currentAnimals, setCurrentAnimals] = useState([]);
            const [foodItems, setFoodItems] = useState([]);
            const [gameActive, setGameActive] = useState(true);
            const [isPaused, setIsPaused] = useState(false);
            const [spawnRate, setSpawnRate] = useState(2000);
            const [speed, setSpeed] = useState(1.0);
            const [feedback, setFeedback] = useState(null);
            const [alertMsg, setAlertMsg] = useState(null);

            // Dynamic Level based on Score
            const currentLevel = Math.floor(score / 300) + 1;

            // Refs for loop
            const requestRef = useRef();
            const lastSpawnTime = useRef(0);
            const foodItemsRef = useRef([]); // Sync with state
            const speedRef = useRef(2.0); // Sync with state
            const beltCountRef = useRef(1); // Sync with state
            const currentAnimalsRef = useRef([]); // Sync with state

            // Initialize
            useEffect(() => {
                startGame();
                return () => cancelAnimationFrame(requestRef.current);
            }, []);

            // Sync Refs
            useEffect(() => { foodItemsRef.current = foodItems; }, [foodItems]);
            useEffect(() => { speedRef.current = speed; }, [speed]);
            useEffect(() => { beltCountRef.current = beltCount; }, [beltCount]);
            useEffect(() => { currentAnimalsRef.current = currentAnimals; }, [currentAnimals]);

            const getRandomAnimal = () => ANIMALS[Math.floor(Math.random() * ANIMALS.length)];

            const generateAnimals = (count) => {
                const animals = [];
                for (let i = 0; i < count; i++) animals.push(getRandomAnimal());
                return animals;
            };

            const startGame = () => {
                const initialBeltCount = 1;
                const initialAnimals = generateAnimals(initialBeltCount);

                setScore(0);
                setLives(3);
                setBeltCount(initialBeltCount);
                setCurrentAnimals(initialAnimals);
                setFoodItems([]);
                setSpawnRate(1000);
                setSpeed(1.0);
                setGameActive(true);
                setIsPaused(false);

                lastSpawnTime.current = Date.now();
                requestRef.current = requestAnimationFrame(gameLoop);
            };

            const gameLoop = () => {
                if (!gameActive || isPaused) {
                    // Just keep loop alive but don't update if paused
                    if (gameActive && !isPaused) requestRef.current = requestAnimationFrame(gameLoop);
                    return;
                }

                const now = Date.now();

                // Spawn Logic
                // Dynamic Spawn Rate: Faster as speed increases or score increases
                // Base 1000ms, reduced by speed factor
                const effectiveSpawnRate = Math.max(500, 1500 - (speedRef.current * 400));

                if (now - lastSpawnTime.current > effectiveSpawnRate) {
                    spawnFood();
                    lastSpawnTime.current = now;
                }

                // Move & Collision Logic
                updatePhysics();

                if (gameActive) requestRef.current = requestAnimationFrame(gameLoop);
            };

            const spawnFood = () => {
                const lanes = BELT_POSITIONS[beltCountRef.current];
                const laneIndex = Math.floor(Math.random() * lanes.length);
                const targetAnimal = currentAnimalsRef.current[laneIndex];

                if (!targetAnimal) return;

                const rand = Math.random();
                let type;
                if (rand < 0.25) type = 'trash';
                else if (rand < 0.6) type = targetAnimal.type === 'herb' ? 'carn' : 'herb'; // Wrong type
                else type = targetAnimal.type; // Correct type

                const list = type === 'trash' ? FOOD_TYPES.TRASH : (type === 'herb' ? FOOD_TYPES.HERB : FOOD_TYPES.CARN);
                const emoji = list[Math.floor(Math.random() * list.length)];

                const newItem = {
                    id: Date.now() + Math.random(),
                    emoji,
                    type,
                    laneIndex,
                    y: -50,
                    sorted: false
                };

                setFoodItems(prev => [...prev, newItem]);
            };

            const updatePhysics = () => {
                setFoodItems(prevItems => {
                    const nextItems = [];
                    // Using fixed threshold for collision since we can't easily get height ref in loop
                    const threshold = 650; // Approx bottom area

                    prevItems.forEach(item => {
                        if (item.sorted) return; // Skip sorted items (waiting for cleanup)

                        const newY = item.y + speedRef.current;

                        if (newY > threshold) {
                            handleReachAnimal(item);
                            // Item effectively removed from "active" physics
                        } else {
                            nextItems.push({ ...item, y: newY });
                        }
                    });
                    return nextItems;
                });
            };

            const handleReachAnimal = (item) => {
                const animal = currentAnimalsRef.current[item.laneIndex];
                const isCorrect = item.type === animal.type;

                if (isCorrect) {
                    addScore(20);
                    showFeedback('+20', item.laneIndex, '#10b981'); // Green
                } else {
                    deductLife();
                    const msg = item.type === 'trash' ? '‡∏Å‡∏¥‡∏ô‡∏Ç‡∏¢‡∏∞!' : '‡∏ú‡∏¥‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó!';
                    showFeedback(`${msg}`, item.laneIndex, '#ef4444'); // Red
                }
            };

            const handleItemClick = (item) => {
                if (item.sorted || isPaused) return;

                // Remove from active list immediately to prevent double clicks
                setFoodItems(prev => prev.filter(i => i.id !== item.id));

                const animal = currentAnimalsRef.current[item.laneIndex];
                const isCorrectFood = item.type === animal.type;

                // We are DISCARDING. 
                // Good discard = Trash OR Wrong Food (Not correct food)
                // Bad discard = Correct Food

                if (!isCorrectFood) {
                    addScore(10);
                    showFeedback('‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°!', item.laneIndex, '#fbbf24'); // Yellow
                } else {
                    deductLife();
                    showFeedback('‡∏ó‡∏¥‡πâ‡∏á‡∏ó‡∏≥‡πÑ‡∏°!', item.laneIndex, '#ef4444');
                }
            };

            const addScore = (points) => {
                setScore(prev => {
                    const newScore = prev + points;
                    checkProgression(prev, newScore);

                    // Check Level Completion (e.g. Target Score based on Hub Level)
                    // ENDLESS MODE: No target score check
                    /*
                    const targetScore = level * 200 + 200;
                    if (newScore >= targetScore) {
                        setGameActive(false);
                        onComplete();
                    }
                    */

                    return newScore;
                });
            };

            const deductLife = () => {
                setLives(prev => {
                    const newLives = prev - 1;
                    if (newLives <= 0) {
                        setGameActive(false);
                        const finalLevel = Math.floor(score / 300) + 1;
                        alert(`‡∏à‡∏ö‡πÄ‡∏Å‡∏°! ‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏ñ‡∏∂‡∏á Level ${finalLevel} (‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: ${score})`);
                        // Proceed to next game instead of exit
                        onComplete(finalLevel);
                    }
                    return newLives;
                });
            };

            const checkProgression = (oldScore, newScore) => {
                // Check 1: Animal Change every 500
                if (Math.floor(newScore / 500) > Math.floor(oldScore / 500)) {
                    triggerAnimalChange();
                }

                // Check 2: Add Belt at 1000
                if (oldScore < 1000 && newScore >= 1000) {
                    triggerBeltUpdate(2);
                }
                // Check 3: Add Belt at 2500
                else if (oldScore < 2500 && newScore >= 2500) {
                    triggerBeltUpdate(3);
                }
            };

            const triggerAnimalChange = () => {
                setAlertMsg({ title: '‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏±‡∏ï‡∏ß‡πå!', sub: '‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô' });
                setTimeout(() => setAlertMsg(null), 1500);

                const count = beltCountRef.current;
                const laneToChange = Math.floor(Math.random() * count);

                setCurrentAnimals(prev => {
                    const next = [...prev];
                    next[laneToChange] = getRandomAnimal();
                    return next;
                });

                // Clear food only in that lane
                setFoodItems(prev => prev.filter(f => f.laneIndex !== laneToChange));
            };

            const triggerBeltUpdate = (newCount) => {
                setAlertMsg({ title: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≤‡∏¢‡∏û‡∏≤‡∏ô!', sub: `‡∏£‡∏∞‡∏î‡∏±‡∏ö ${newCount === 2 ? '‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ' : '‡πÇ‡∏õ‡∏£'} ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß` });
                setTimeout(() => setAlertMsg(null), 2000);

                setBeltCount(newCount);
                setCurrentAnimals(generateAnimals(newCount));

                // Reset everything for fairness
                setFoodItems([]);
                setSpeed(1.0); // Reset speed
                setSpawnRate(1000);
            };

            const showFeedback = (text, laneIndex, color) => {
                const pos = BELT_POSITIONS[beltCountRef.current][laneIndex];
                setFeedback({ text, left: `${pos}%`, color, id: Date.now() });
                setTimeout(() => setFeedback(null), 800);
            };

            // Restart Loop on state changes that affect ref logic (like Pause)
            useEffect(() => {
                if (gameActive && !isPaused) {
                    lastSpawnTime.current = Date.now();
                    requestRef.current = requestAnimationFrame(gameLoop);
                } else {
                    cancelAnimationFrame(requestRef.current);
                }
            }, [isPaused, gameActive]);

            return (
                <div className="flex-1 flex flex-col items-center relative overflow-hidden bg-zinc-900 font-kanit w-full h-full game-bg-dark">
                    {/* Background Pattern */}
                    <div className="absolute inset-0 opacity-10 pointer-events-none" style={{ backgroundImage: 'radial-gradient(#fff 2px, transparent 2px)', backgroundSize: '30px 30px' }}></div>

                    {/* HUD */}
                    <div className="w-full p-4 flex justify-between items-start z-50 pointer-events-none relative">
                        <div className="flex flex-col gap-2">
                            <div className="bg-white/90 text-slate-800 px-4 py-1 rounded-full font-bold shadow-lg flex items-center gap-2">
                                <span>‚≠ê</span> {score} <span className="text-slate-400 text-sm">| Lv. {currentLevel}</span>
                            </div>
                            <div className="bg-white/90 text-blue-600 px-4 py-1 rounded-full font-bold shadow-lg flex items-center gap-2">
                                <span>‚ö°</span> ‡∏™‡∏≤‡∏¢‡∏û‡∏≤‡∏ô {beltCount}
                            </div>
                        </div>
                        <div className="flex flex-col gap-2 items-end pointer-events-auto">
                            <button onClick={() => setIsPaused(!isPaused)} className="bg-white text-slate-800 p-2 rounded-xl shadow-lg active:scale-95 transition">
                                <Icon path={isPaused ? Icons.Play : Icons.Pause} />
                            </button>
                            <div className="flex text-red-500 text-2xl drop-shadow-md">
                                {Array(Math.max(0, lives)).fill('‚ù§Ô∏è').map((_, i) => <span key={i}>‚ù§Ô∏è</span>)}
                            </div>
                        </div>
                    </div>

                    {/* ALERTS */}
                    {alertMsg && (
                        <div className="absolute top-1/3 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white text-slate-800 px-8 py-6 rounded-3xl shadow-2xl z-[60] text-center w-3/4 animate-pop-in border-4 border-yellow-400">
                            <h2 className="text-3xl font-black mb-1 text-yellow-500">{alertMsg.title}</h2>
                            <p className="text-slate-500 font-bold">{alertMsg.sub}</p>
                        </div>
                    )}

                    {/* FEEDBACK */}
                    {feedback && (
                        <div className="absolute top-1/2 -translate-x-1/2 -translate-y-1/2 text-4xl font-black z-[60] animate-bounce-slow pointer-events-none whitespace-nowrap"
                            style={{ left: feedback.left, color: feedback.color, textShadow: '2px 2px 0 #fff' }}>
                            {feedback.text}
                        </div>
                    )}

                    {/* GAME AREA */}
                    <div className="relative w-full h-full max-w-md mx-auto flex-1">
                        {/* Belts & Animals */}
                        {BELT_POSITIONS[beltCount].map((pos, idx) => (
                            <React.Fragment key={idx}>
                                {/* Belt */}
                                <div className="absolute top-0 h-[80%] bg-slate-600 border-x-4 border-black/20 rounded-b-3xl shadow-xl overflow-hidden"
                                    style={{ left: `calc(${pos}% - ${beltCount === 3 ? '11%' : (beltCount === 2 ? '16%' : '22%')})`, width: beltCount === 3 ? '22%' : (beltCount === 2 ? '32%' : '45%') }}>
                                    <div className="w-full h-full opacity-20 belt-marking" style={{ animation: `moveBelt 1s linear infinite reverse` }}></div>
                                </div>

                                {/* Animal */}
                                <div className="absolute bottom-[20px] -translate-x-1/2 flex flex-col items-center z-20 transition-all duration-300"
                                    style={{ left: `${pos}%` }}>
                                    <div className="bg-white border-2 border-slate-100 px-3 py-1 rounded-full mb-1 shadow-sm text-slate-700 font-bold text-xs flex items-center gap-1 whitespace-nowrap">
                                        <span>{currentAnimals[idx]?.icon}</span> ‡∏Å‡∏¥‡∏ô{currentAnimals[idx]?.name}
                                    </div>
                                    <div className="text-[5rem] leading-none drop-shadow-xl filter">
                                        {currentAnimals[idx]?.emoji}
                                    </div>
                                </div>
                            </React.Fragment>
                        ))}

                        {/* Food Items */}
                        {foodItems.map(item => (
                            <div key={item.id}
                                onPointerDown={(e) => { e.stopPropagation(); handleItemClick(item); }}
                                className="absolute -translate-x-1/2 flex items-center justify-center text-[3.5rem] z-30 cursor-pointer select-none active:scale-90 transition-transform touch-manipulation"
                                style={{ left: `${BELT_POSITIONS[beltCount][item.laneIndex]}%`, top: item.y }}>
                                {item.emoji}
                            </div>
                        ))}
                    </div>

                    {/* Pause Overlay */}
                    {isPaused && (
                        <div className="absolute inset-0 bg-black/60 backdrop-blur-sm z-[70] flex items-center justify-center">
                            <div className="bg-white p-8 rounded-3xl text-center">
                                <h2 className="text-4xl font-black text-slate-800 mb-6">‡∏û‡∏±‡∏Å‡∏¢‡∏Å</h2>
                                <button onClick={() => setIsPaused(false)} className="w-full bg-green-500 text-white py-3 rounded-xl font-bold text-xl mb-3 shadow-lg">‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠</button>
                                <button onClick={onExit} className="w-full bg-slate-200 text-slate-600 py-3 rounded-xl font-bold text-xl">‡∏≠‡∏≠‡∏Å</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // ==========================================
        // GAME 4: LANGUAGE
        // ==========================================
        function LanguageGame({ level, onComplete, onExit }) {
            const WORDS = [
                { q: "‡∏£‡∏ñ", a: ["‡∏£‡∏ñ", "‡∏£‡∏™"], correct: "‡∏£‡∏ñ" },
                { q: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç", a: ["‡∏™‡∏∏‡∏Ç", "‡∏®‡∏∏‡∏Å‡∏£‡πå"], correct: "‡∏™‡∏∏‡∏Ç" },
                { q: "‡∏î‡∏ß‡∏á‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå", a: ["‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå", "‡∏à‡∏±‡∏ô‡∏ó‡∏ô‡πå"], correct: "‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå" },
                { q: "‡∏£‡∏™‡∏ä‡∏≤‡∏ï‡∏¥", a: ["‡∏£‡∏ñ", "‡∏£‡∏™"], correct: "‡∏£‡∏™" },
                { q: "‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå", a: ["‡∏™‡∏∏‡∏Ç", "‡∏®‡∏∏‡∏Å‡∏£‡πå"], correct: "‡∏®‡∏∏‡∏Å‡∏£‡πå" }
            ];

            const [currentQ, setCurrentQ] = useState(null);
            const [stage, setStage] = useState(1);
            const TOTAL_STAGES = 15;

            useEffect(() => {
                // Randomize question
                setCurrentQ(WORDS[Math.floor(Math.random() * WORDS.length)]);
            }, [level, stage]);

            const handleAnswer = (ans) => {
                if (ans === currentQ.correct) {
                    if (stage < TOTAL_STAGES) {
                        setStage(s => s + 1);
                    } else {
                        onComplete();
                    }
                } else {
                    alert('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö');
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center justify-center p-6 bg-purple-50 h-full relative">
                    <div className="absolute top-4 right-4 bg-purple-200 text-purple-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Stage {stage}/{TOTAL_STAGES}</div>

                    <div className="bg-white p-8 rounded-3xl shadow-lg text-center w-full mb-8">
                        <span className="text-sm text-slate-400 font-bold uppercase">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå</span>
                        <h2 className="text-4xl font-bold text-slate-800 mt-2">{currentQ?.q}</h2>
                    </div>

                    <div className="grid grid-cols-1 w-full gap-4">
                        {currentQ?.a.map((ans, i) => (
                            <button key={i} onClick={() => handleAnswer(ans)} className="bg-white border-2 border-purple-100 py-4 rounded-xl text-xl font-bold text-purple-700 hover:bg-purple-100 transition active:scale-95">
                                {ans}
                            </button>
                        ))}
                    </div>
                </div>
            );
        }

        // ==========================================
        // GAME 5: EXECUTIVE (Updated Logic)
        // ==========================================
        function ExecutiveGame({ level, onComplete, onExit }) {
            const ALL_ANIMALS = ['ü¶Å', 'üêò', 'ü¶í', 'üêí', 'ü¶ì', 'üêØ', 'ü¶õ', 'üêº', 'ü¶ä', 'üê®', 'üêÆ', 'üê∑', 'üê∏', 'üêî', 'üêß'];

            const [grid, setGrid] = useState([]);
            const [solution, setSolution] = useState([]);
            const [rows, setRows] = useState(1);
            const [cols, setCols] = useState(3);
            const [hints, setHints] = useState([]);
            const [availableAnimals, setAvailableAnimals] = useState([]);
            const [selectedAnimal, setSelectedAnimal] = useState(null);
            const [stage, setStage] = useState(1);
            const TOTAL_STAGES = 15;

            // Level Scaling (Cap difficulty logic at level 15)
            const effectiveLevel = Math.min(level, 15);

            useEffect(() => {
                initLevel();
            }, [level, stage]);

            const initLevel = () => {
                let r = 1, c = 3;
                if (effectiveLevel >= 4 && effectiveLevel <= 6) { r = 2; c = 3; } // 6 slots
                else if (effectiveLevel >= 7) { r = 3; c = 3; } // 9 slots

                // For level 2-3, use 2x2 for variety
                if (effectiveLevel === 2 || effectiveLevel === 3) { r = 2; c = 2; }

                setRows(r);
                setCols(c);

                const totalSlots = r * c;
                const roundAnimals = [...ALL_ANIMALS].sort(() => Math.random() - 0.5).slice(0, totalSlots);

                setAvailableAnimals(roundAnimals);
                const sol = [...roundAnimals].sort(() => Math.random() - 0.5);
                setSolution(sol);
                setGrid(new Array(totalSlots).fill(null));

                generateHints(sol, r, c);
            };

            const getPosName = (idx, r, c) => {
                const row = Math.floor(idx / c);
                const col = idx % c;

                // 1x3: ‡∏ã‡πâ‡∏≤‡∏¢, ‡∏Å‡∏•‡∏≤‡∏á, ‡∏Ç‡∏ß‡∏≤
                if (r === 1) {
                    if (c === 3) return ["‡∏ä‡πà‡∏≠‡∏á‡∏ã‡πâ‡∏≤‡∏¢", "‡∏ä‡πà‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á", "‡∏ä‡πà‡∏≠‡∏á‡∏Ç‡∏ß‡∏≤"][col];
                    return col === 0 ? "‡∏ã‡πâ‡∏≤‡∏¢" : "‡∏Ç‡∏ß‡∏≤";
                }

                // 2x2: ‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢, ‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏Ç‡∏ß‡∏≤, ‡∏Ø‡∏•‡∏Ø
                if (r === 2 && c === 2) {
                    const v = row === 0 ? "‡∏ö‡∏ô" : "‡∏•‡πà‡∏≤‡∏á";
                    const h = col === 0 ? "‡∏ã‡πâ‡∏≤‡∏¢" : "‡∏Ç‡∏ß‡∏≤";
                    return `‡∏°‡∏∏‡∏°${v}${h}`;
                }

                // 2x3 & 3x3: ‡πÅ‡∏ñ‡∏ß‡∏ö‡∏ô/‡∏•‡πà‡∏≤‡∏á + ‡∏ã‡πâ‡∏≤‡∏¢/‡∏Å‡∏•‡∏≤‡∏á/‡∏Ç‡∏ß‡∏≤
                const vNames = r === 2 ? ["‡∏ö‡∏ô", "‡∏•‡πà‡∏≤‡∏á"] : ["‡∏ö‡∏ô", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏•‡πà‡∏≤‡∏á"];
                const hNames = ["‡∏ã‡πâ‡∏≤‡∏¢", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏Ç‡∏ß‡∏≤"];

                // Construct simpler names
                // e.g. "‡πÅ‡∏ñ‡∏ß‡∏ö‡∏ô ‡∏ä‡πà‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á" or "‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢" if it's a corner
                const vName = vNames[row];
                const hName = hNames[col];

                if (hName === "‡∏Å‡∏•‡∏≤‡∏á") return `‡πÅ‡∏ñ‡∏ß${vName} ‡∏ä‡πà‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á`;
                if (vName === "‡∏Å‡∏•‡∏≤‡∏á") return `‡πÅ‡∏ñ‡∏ß‡∏Å‡∏•‡∏≤‡∏á ‡∏ä‡πà‡∏≠‡∏á${hName}`;

                return `‡∏°‡∏∏‡∏°${vName}${hName}`; // e.g., ‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢
            };

            const generateHints = (sol, r, c) => {
                const total = r * c;
                const newHints = [];
                const visited = new Set();

                // 1. Reveal one anchor position (usually a corner or edge)
                const startIdx = Math.floor(Math.random() * total);
                visited.add(startIdx);
                newHints.push({ text: `üìç ${sol[startIdx]} ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà ${getPosName(startIdx, r, c)}` });

                // 2. Generate relative hints until all connected
                let attempts = 0;
                while (visited.size < total && attempts < 100) {
                    attempts++;
                    // Pick a visited node to branch from
                    const u = [...visited][Math.floor(Math.random() * visited.size)];
                    const uRow = Math.floor(u / c);
                    const uCol = u % c;

                    const neighbors = [
                        { idx: u - c, dir: 'up', valid: uRow > 0 },
                        { idx: u + c, dir: 'down', valid: uRow < r - 1 },
                        { idx: u - 1, dir: 'left', valid: uCol > 0 },
                        { idx: u + 1, dir: 'right', valid: uCol < c - 1 }
                    ].filter(n => n.valid);

                    if (neighbors.length === 0) continue;

                    const target = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const v = target.idx;

                    if (!visited.has(v) || Math.random() > 0.8) {
                        const a1 = sol[u]; // Reference animal (Known)
                        const a2 = sol[v]; // Target animal (Unknown)

                        let txt = "";
                        // Describe A2 relative to A1
                        if (target.dir === 'up') txt = `üîº ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á ${a1}`;
                        if (target.dir === 'down') txt = `üîΩ ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á ${a1}`;
                        if (target.dir === 'left') txt = `üëà ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á ${a1}`;
                        if (target.dir === 'right') txt = `üëâ ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á ${a1}`;

                        // Check for duplicates
                        if (!newHints.some(h => h.text === txt)) {
                            newHints.push({ text: txt });
                            visited.add(v);
                        }
                    }
                }
                setHints(newHints);
            };

            const handleSlotClick = (idx) => {
                if (!selectedAnimal) return;

                // Move animal if already placed
                const currentIdx = grid.indexOf(selectedAnimal);
                const newGrid = [...grid];
                if (currentIdx !== -1) newGrid[currentIdx] = null;

                newGrid[idx] = selectedAnimal;
                setGrid(newGrid);
            };

            const checkAnswer = () => {
                if (grid.some(x => x === null)) {
                    alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á");
                    return;
                }
                const isCorrect = grid.every((val, i) => val === solution[i]);
                if (isCorrect) {
                    if (stage < TOTAL_STAGES) {
                        setStage(s => s + 1);
                    } else {
                        onComplete();
                    }
                } else {
                    alert("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å ‡∏•‡∏≠‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞");
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center p-4 bg-rose-50 h-full relative">
                    <div className="absolute top-4 right-4 bg-rose-200 text-rose-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Stage {stage}/{TOTAL_STAGES}</div>

                    {/* Hints */}
                    <div className="bg-white rounded-2xl p-4 shadow-sm border-2 border-rose-200 mb-4 w-full max-h-[35%] overflow-y-auto">
                        <h2 className="font-bold text-rose-800 mb-2 flex items-center gap-2"><span className="text-xl">üïµÔ∏è</span> ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏™‡∏∑‡∏ö</h2>
                        <ul className="space-y-2 text-sm font-medium text-slate-600">
                            {hints.map((h, i) => (
                                <li key={i} className="pl-2 border-l-4 border-rose-100">{h.text}</li>
                            ))}
                        </ul>
                    </div>

                    {/* Grid */}
                    <div className="flex-1 flex items-center justify-center min-h-0 w-full">
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: `repeat(${cols}, 1fr)`,
                            gap: '8px',
                            width: '100%',
                            maxWidth: '350px',
                            aspectRatio: `${cols}/${rows}`
                        }}>
                            {grid.map((animal, i) => (
                                <div key={i} onClick={() => handleSlotClick(i)}
                                    className={`relative bg-white rounded-xl border-2 border-rose-100 flex items-center justify-center text-4xl shadow-sm transition-all active:scale-95 cursor-pointer ${animal ? 'border-rose-400 bg-rose-50' : ''}`}>
                                    <span className="absolute top-1 left-2 text-[10px] text-slate-300 font-bold">{i + 1}</span>
                                    {animal}
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="bg-white p-4 w-full rounded-2xl shadow-sm border border-rose-100 mt-4">
                        <div className="flex justify-center gap-2 mb-4 flex-wrap">
                            {availableAnimals.map(animal => (
                                <button key={animal}
                                    onClick={() => setSelectedAnimal(animal)}
                                    className={`w-12 h-12 rounded-lg text-2xl flex items-center justify-center border-2 transition-all ${selectedAnimal === animal ? 'border-rose-500 bg-rose-100 -translate-y-1 shadow-md' : 'border-slate-200 bg-slate-50'}`}>
                                    {animal}
                                </button>
                            ))}
                        </div>
                        <button onClick={checkAnswer} className="w-full bg-rose-500 text-white font-bold py-3 rounded-xl shadow-md active:scale-95 transition">
                            ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö
                        </button>
                    </div>
                </div>
            );
        }

        // ==========================================
        // WELCOME SCREEN
        // ==========================================
        const WelcomeScreen = ({ onStart }) => (
            <div className="w-full h-full flex flex-col items-center justify-center bg-emerald-50 relative overflow-hidden font-kanit p-6">
                {/* Decorative Background */}
                <div className="absolute top-[-10%] right-[-10%] w-64 h-64 bg-emerald-200 rounded-full blur-3xl opacity-50 animate-pulse-custom"></div>
                <div className="absolute bottom-[-10%] left-[-10%] w-64 h-64 bg-yellow-200 rounded-full blur-3xl opacity-50 animate-pulse-custom" style={{ animationDelay: '1s' }}></div>

                <div className="z-10 flex flex-col items-center text-center">
                    <div className="bg-white p-8 rounded-[3rem] shadow-xl mb-8 animate-pop-in border-4 border-emerald-100">
                        <div className="text-8xl mb-4 animate-bounce-slow">ü¶Å</div>
                        <h1 className="text-4xl font-black text-emerald-800 tracking-tight leading-tight">
                            Zoo<br /><span className="text-emerald-500">Brain Fit</span>
                        </h1>
                    </div>

                    <p className="text-slate-500 text-lg mb-12 font-medium max-w-[250px] animate-slide-up">
                        ‡∏ù‡∏∂‡∏Å‡∏™‡∏°‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏•‡∏≠‡∏á‡∏õ‡∏±‡∏ç‡∏ç‡∏≤<br />‡πÑ‡∏õ‡∏Å‡∏±‡∏ö‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ô‡πà‡∏≤‡∏£‡∏±‡∏Å
                    </p>

                    <button
                        onClick={onStart}
                        className="w-full max-w-xs bg-emerald-600 hover:bg-emerald-700 text-white text-2xl font-black py-5 rounded-2xl shadow-xl shadow-emerald-200 transform transition-all active:scale-95 flex items-center justify-center gap-3 animate-slide-up"
                    >
                        <Icon path={Icons.Play} size={28} fill="currentColor" />
                        ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
                    </button>
                </div>

                <div className="absolute bottom-6 text-slate-400 text-xs font-bold opacity-60">
                    v1.5.0 ‚Ä¢ Zoo Edition
                </div>
            </div>
        );

        // ==========================================
        // MAIN APP COMPONENT
        // ==========================================
        function App() {
            // STATE
            const [progress, setProgress] = useState(() => {
                const saved = localStorage.getItem('zoo_progress');
                return saved ? JSON.parse(saved) : { memory: 1, visuospatial: 1, attention: 1, language: 1, executive: 1 };
            });

            const [selectedGames, setSelectedGames] = useState([]);
            const [activeGameIndex, setActiveGameIndex] = useState(null);
            const [screen, setScreen] = useState('welcome'); // welcome, selection, playing
            const [showExitConfirm, setShowExitConfirm] = useState(false);

            useEffect(() => {
                localStorage.setItem('zoo_progress', JSON.stringify(progress));
            }, [progress]);

            // Handlers
            const toggleSelection = (gameId) => {
                if (selectedGames.includes(gameId)) {
                    setSelectedGames(prev => prev.filter(id => id !== gameId));
                } else {
                    if (selectedGames.length < 3) {
                        setSelectedGames(prev => [...prev, gameId]);
                    }
                }
            };

            const resetProgress = (gameId, e) => {
                e.stopPropagation();
                // Custom confirm modal would be better, but native is okay here for admin-like task
                if (confirm(`‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ç‡∏≠‡∏á ${GAMES[gameId].name} ‡πÄ‡∏õ‡πá‡∏ô 1?`)) {
                    setProgress(prev => ({ ...prev, [gameId]: 1 }));
                }
            };

            const startSession = () => {
                if (selectedGames.length === 3) {
                    setActiveGameIndex(0);
                    setScreen('playing');
                }
            };

            const handleLevelComplete = (achievedLevel) => {
                const currentGameId = selectedGames[activeGameIndex];

                // Update Progress (Save if higher)
                if (achievedLevel) {
                    setProgress(prev => ({
                        ...prev,
                        [currentGameId]: Math.max(prev[currentGameId], achievedLevel)
                    }));
                } else {
                    // Default increment (for non-endless games or simple completion)
                    setProgress(prev => ({ ...prev, [currentGameId]: prev[currentGameId] + 1 }));
                }

                // Move to next game in session
                if (activeGameIndex < 2) {
                    // Small delay or modal could be here
                    setTimeout(() => {
                        alert(`‡πÑ‡∏õ‡∏ï‡πà‡∏≠‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà ${activeGameIndex + 2}`);
                        setActiveGameIndex(prev => prev + 1);
                    }, 500);
                } else {
                    setTimeout(() => {
                        alert("üéâ ‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß! ‡∏û‡∏±‡∏Å‡∏ú‡πà‡∏≠‡∏ô‡πÑ‡∏î‡πâ");
                        setScreen('selection');
                        setActiveGameIndex(null);
                        setSelectedGames([]);
                    }, 500);
                }
            };

            const exitSession = () => {
                setShowExitConfirm(true);
            };

            const confirmExitSession = () => {
                setShowExitConfirm(false);
                setScreen('selection');
                setActiveGameIndex(null);
            };

            const handleWelcomeStart = () => {
                setScreen('selection');
            };

            // RENDER SCREEN
            if (screen === 'welcome') {
                return <WelcomeScreen onStart={handleWelcomeStart} />;
            }

            if (screen === 'playing') {
                if (activeGameIndex === null || !selectedGames[activeGameIndex]) {
                    // Safeguard if activeGameIndex is invalid
                    return <div className="w-full h-full flex items-center justify-center">Loading...</div>;
                }
                const currentGameId = selectedGames[activeGameIndex];
                const gameData = GAMES[currentGameId];

                // Safety check for game data
                if (!gameData) {
                    return <div className="w-full h-full flex items-center justify-center">Error: Game Data Not Found</div>;
                }

                const currentLevel = progress[currentGameId];

                return (
                    <div className="w-full h-full flex flex-col font-kanit relative">
                        {/* Session Header */}
                        <div className="bg-emerald-600 text-white p-4 flex justify-between items-center shadow-md z-50 relative">
                            <button onClick={exitSession} className="bg-emerald-700/50 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-all active:scale-95 border border-emerald-500/30">
                                <Icon path={Icons.Home} size={20} />
                                <span className="text-sm font-bold">‡∏≠‡∏≠‡∏Å</span>
                            </button>
                            <div className="font-bold text-lg">‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà {activeGameIndex + 1}/3 : {gameData.name}</div>
                            <div className="w-16"></div> {/* Spacer for balance */}
                        </div>

                        {/* Game Component */}
                        <div className="flex-1 relative overflow-hidden z-0">
                            {currentGameId === 'memory' && <MemoryGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} />}
                            {currentGameId === 'visuospatial' && <VisuospatialGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} />}
                            {currentGameId === 'attention' && <AttentionGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} />}
                            {currentGameId === 'language' && <LanguageGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} />}
                            {currentGameId === 'executive' && <ExecutiveGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} />}
                        </div>

                        {/* Custom Exit Modal */}
                        {showExitConfirm && (
                            <div className="absolute inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center p-6 animate-fade-in">
                                <div className="bg-white rounded-3xl p-8 w-full max-w-xs text-center shadow-2xl animate-pop-in">
                                    <div className="text-6xl mb-4">üè†</div>
                                    <h2 className="text-2xl font-black text-slate-800 mb-2">‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°?</h2>
                                    <p className="text-slate-500 mb-8">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏î‡πà‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>
                                    <div className="flex flex-col gap-3">
                                        <button onClick={confirmExitSession} className="w-full bg-red-500 hover:bg-red-600 text-white py-3 rounded-xl font-bold text-lg shadow-lg active:scale-95 transition">
                                            ‡πÉ‡∏ä‡πà, ‡∏≠‡∏≠‡∏Å‡πÄ‡∏•‡∏¢
                                        </button>
                                        <button onClick={() => setShowExitConfirm(false)} className="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 py-3 rounded-xl font-bold text-lg active:scale-95 transition">
                                            ‡πÑ‡∏°‡πà, ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // Selection Screen
            return (
                <div className="w-full h-full flex flex-col bg-emerald-50 font-kanit overflow-hidden">
                    <header className="pt-8 pb-4 px-6 bg-white rounded-b-[2.5rem] shadow-sm z-10 relative">
                        <button
                            onClick={() => setScreen('welcome')}
                            className="absolute top-6 left-4 p-2 rounded-full hover:bg-slate-100 text-slate-400 hover:text-slate-600 transition"
                        >
                            <Icon path={Icons.ArrowLeft} size={24} />
                        </button>
                        <div className="text-center mt-1">
                            <h1 className="text-3xl font-black text-emerald-800 mb-1">Zoo Brain Fit</h1>
                            <p className="text-slate-500 text-sm">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 3 ‡∏´‡∏°‡∏ß‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ù‡∏∂‡∏Å‡∏™‡∏°‡∏≠‡∏á</p>
                        </div>
                    </header>

                    <main className="flex-1 overflow-y-auto p-6 space-y-4 no-scrollbar">
                        {Object.values(GAMES).map(game => {
                            const isSelected = selectedGames.includes(game.id);
                            const currentLv = progress[game.id];

                            return (
                                <div key={game.id}
                                    onClick={() => toggleSelection(game.id)}
                                    className={`relative p-4 rounded-3xl border-2 transition-all cursor-pointer flex items-center gap-4 shadow-sm active:scale-95
                                        ${isSelected ? 'border-emerald-500 bg-emerald-100 ring-2 ring-emerald-200' : 'border-white bg-white hover:border-emerald-200'}
                                     `}
                                >
                                    {/* Selection Indicator */}
                                    <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center shrink-0
                                        ${isSelected ? 'bg-emerald-500 border-emerald-500' : 'border-slate-200 bg-slate-50'}
                                    `}>
                                        {isSelected && <Icon path={Icons.Check} size={14} className="text-white" />}
                                    </div>

                                    {/* Icon */}
                                    <div className={`w-14 h-14 rounded-2xl flex items-center justify-center text-3xl shrink-0 ${game.color.replace('text-', 'bg-').split(' ')[0]}`}>
                                        {game.icon}
                                    </div>

                                    {/* Info */}
                                    <div className="flex-1">
                                        <h3 className="font-bold text-slate-800 text-lg">{game.name}</h3>
                                        <p className="text-slate-400 text-xs">{game.desc}</p>
                                    </div>

                                    {/* Level & Reset */}
                                    <div className="flex flex-col items-end gap-2">
                                        <span className="text-xs font-bold bg-slate-100 text-slate-600 px-2 py-1 rounded-lg">
                                            Lv. {currentLv}
                                        </span>
                                        <button
                                            onClick={(e) => resetProgress(game.id, e)}
                                            className="p-2 text-slate-300 hover:text-red-400 hover:bg-red-50 rounded-full transition"
                                        >
                                            <Icon path={Icons.Trash} size={16} />
                                        </button>
                                    </div>
                                </div>
                            );
                        })}
                        <div className="h-20"></div>
                    </main>

                    {/* Footer / Start Button */}
                    <div className="absolute bottom-0 w-full p-6 bg-gradient-to-t from-white via-white/90 to-transparent pointer-events-none flex justify-center">
                        <button
                            onClick={startSession}
                            disabled={selectedGames.length !== 3}
                            className={`w-full max-w-sm py-4 rounded-2xl font-black text-xl shadow-xl flex items-center justify-center gap-2 pointer-events-auto transition-all
                                ${selectedGames.length === 3
                                    ? 'bg-emerald-600 text-white hover:bg-emerald-700 hover:scale-105 active:scale-95'
                                    : 'bg-slate-200 text-slate-400 cursor-not-allowed'}
                            `}
                        >
                            {selectedGames.length === 3 ? (
                                <><span>üöÄ</span> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô!</>
                            ) : (
                                <span>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏µ‡∏Å {3 - selectedGames.length} ‡∏´‡∏°‡∏ß‡∏î</span>
                            )}
                        </button>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>