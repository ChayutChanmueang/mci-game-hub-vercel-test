<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zoo Brain Training</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600;800&family=Fredoka:wght@600&family=Kanit:wght@400;600&display=swap"
        rel="stylesheet">

    <style type="text/tailwindcss">
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #0f172a;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #root {
            width: 100%;
            height: 100vh;
            background-color: #f0fdf4;
            /* Light Green Bg */
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 500px) {
            #root {
                max-width: 414px;
                max-height: 896px;
                height: 90vh;
                border-radius: 40px;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
                border: 8px solid #14532d;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes popIn {
            0% {
                transform: scale(0.9);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse-custom {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @keyframes bounce-slow {

            0%,
            100% {
                transform: translateY(-5%);
            }

            50% {
                transform: translateY(5%);
            }
        }

        @keyframes pulse-dot {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }

            70% {
                transform: translate(-50%, -50%) scale(1.3);
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        @keyframes moveBelt {
            0% {
                top: -10%;
            }

            100% {
                top: 100%;
            }
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-10px);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 0;
            }

            20% {
                transform: translateY(-20px) scale(1.1);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) scale(1);
                opacity: 0;
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out;
        }

        .animate-slide-up {
            animation: slideUp 0.4s ease-out forwards;
        }

        .animate-pop-in {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .animate-pulse-custom {
            animation: pulse-custom 2s infinite;
        }

        .animate-bounce-slow {
            animation: bounce-slow 3s infinite ease-in-out;
        }

        .animate-pulse-dot {
            animation: pulse-dot 2s infinite;
        }

        .animate-move-belt {
            animation: moveBelt 3s linear infinite;
        }

        .animate-bounce-animal {
            animation: bounce 0.6s infinite alternate;
        }

        .animate-shake {
            animation: shake 0.5s;
        }

        .animate-float-up {
            animation: floatUp 0.8s forwards;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Common UI Classes */
        .btn-primary {
            @apply bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-2xl shadow-lg transition-all active:scale-95 flex items-center justify-center gap-2;
        }

        .btn-secondary {
            @apply bg-white border-2 border-emerald-100 text-emerald-700 font-bold py-3 px-6 rounded-2xl shadow-sm transition-all active:scale-95 flex items-center justify-center gap-2;
        }

        .card {
            @apply bg-white rounded-3xl shadow-sm border border-emerald-100 p-4;
        }

        .font-fredoka {
            font-family: 'Fredoka', sans-serif;
        }

        /* Attention Game Specifics */
        .game-bg-dark {
            background-color: #111;
            background-image: radial-gradient(#333 2px, transparent 2px);
            background-size: 30px 30px;
        }

        .belt {
            position: absolute;
            top: -5%;
            height: 85%;
            background: #64748b;
            border-left: 3px solid rgba(0, 0, 0, 0.1);
            border-right: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 0 0 20px 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .belt-marking {
            position: absolute;
            width: 100%;
            height: 2%;
            background: rgba(255, 255, 255, 0.1);
        }

        .animal-slot {
            position: absolute;
            bottom: 80px;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 30%;
        }

        .animal-emoji {
            font-size: 4.5rem;
            line-height: 1;
            filter: drop-shadow(0 8px 12px rgba(0, 0, 0, 0.15));
            transition: transform 0.2s;
            z-index: 20;
            cursor: pointer;
        }

        .animal-diet-bubble {
            background: white;
            color: #334155;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'Fredoka', sans-serif;
            margin-bottom: -5px;
            z-index: 25;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 2px solid #f1f5f9;
            transform: scale(0.95);
        }

        .food-item {
            position: absolute;
            width: 60px;
            height: 60px;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            z-index: 30;
            cursor: pointer;
            user-select: none;
            filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.1));
            touch-action: manipulation;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- GLOBAL CONSTANTS ---
        const MAX_LEVEL = 15;
        const GAMES = {
            memory: { id: 'memory', name: 'Memory', icon: 'üß†', desc: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥', color: 'bg-orange-100 text-orange-600' },
            visuospatial: { id: 'visuospatial', name: 'Visuospatial', icon: 'üìê', desc: '‡∏°‡∏¥‡∏ï‡∏¥‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå', color: 'bg-blue-100 text-blue-600' },
            attention: { id: 'attention', name: 'Attention', icon: '‚ö°', desc: '‡∏™‡∏°‡∏≤‡∏ò‡∏¥', color: 'bg-yellow-100 text-yellow-600' },
            language: { id: 'language', name: 'Language', icon: 'üó£Ô∏è', desc: '‡∏†‡∏≤‡∏©‡∏≤', color: 'bg-purple-100 text-purple-600' },
            executive: { id: 'executive', name: 'Executive', icon: 'üß©', desc: '‡∏Å‡∏≤‡∏£‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£', color: 'bg-rose-100 text-rose-600' }
        };

        // --- ICONS ---
        const Icon = ({ path, size = 24, className = "", viewBox = "0 0 24 24", fill = "none", stroke = "currentColor" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox={viewBox} fill={fill} stroke={stroke} strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {path}
            </svg>
        );
        const Icons = {
            Play: <polygon points="5 3 19 12 5 21 5 3"></polygon>,
            Home: <><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" /><polyline points="9 22 9 12 15 12 15 22" /></>,
            Refresh: <><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" /><path d="M16 21h5v-5" /></>,
            Trash: <><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></>,
            Check: <polyline points="20 6 9 17 4 12"></polyline>,
            Lock: <><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></>,
            Logout: <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>,
            Heart: <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>,
            Trophy: <><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" /><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" /><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z" /></>,
            Clock: <><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></>,
            ChevronRight: <path d="m9 18 6-6-6-6" />,
            Star: <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" />,
            ArrowLeft: <><line x1="19" y1="12" x2="5" y2="12" /><polyline points="12 19 5 12 12 5" /></>,
            Pause: <><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></>,
            X: <><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>,
            RotateCcw: <><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5"></path></>,
            Grid4: <><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></>
        };

        // ==========================================
        // GAME 1: MEMORY (Updated)
        // ==========================================
        function MemoryGame({ level, onComplete, onExit, updateStats }) {
            // New Item Pool
            const MEMORY_ITEMS = [
                { id: 'lion', name: '‡∏™‡∏¥‡∏á‡πÇ‡∏ï', icon: 'ü¶Å' }, { id: 'elephant', name: '‡∏ä‡πâ‡∏≤‡∏á', icon: 'üêò' },
                { id: 'monkey', name: '‡∏•‡∏¥‡∏á', icon: 'üêµ' }, { id: 'penguin', name: '‡πÄ‡∏û‡∏ô‡∏Å‡∏ß‡∏¥‡∏ô', icon: 'üêß' },
                { id: 'giraffe', name: '‡∏¢‡∏µ‡∏£‡∏≤‡∏ü', icon: 'ü¶í' }, { id: 'zebra', name: '‡∏°‡πâ‡∏≤‡∏•‡∏≤‡∏¢', icon: 'ü¶ì' },
                { id: 'panda', name: '‡πÅ‡∏û‡∏ô‡∏î‡πâ‡∏≤', icon: 'üêº' }, { id: 'tiger', name: '‡πÄ‡∏™‡∏∑‡∏≠', icon: 'üêØ' },
                { id: 'koala', name: '‡πÇ‡∏Ñ‡∏≠‡∏≤‡∏•‡πà‡∏≤', icon: 'üê®' }, { id: 'cow', name: '‡∏ß‡∏±‡∏ß', icon: 'üêÆ' },
                { id: 'pig', name: '‡∏´‡∏°‡∏π', icon: 'üê∑' }, { id: 'frog', name: '‡∏Å‡∏ö', icon: 'üê∏' },
            ];

            const DISTRACTION_QUIZ_POOL = [
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô '‡∏Ñ‡∏≠‡∏¢‡∏≤‡∏ß' ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î?", a: 'ü¶í', options: ['ü¶Å', 'ü¶í', 'üêß'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏ä‡∏≠‡∏ö‡∏Å‡∏¥‡∏ô '‡∏Å‡∏•‡πâ‡∏ß‡∏¢'?", a: 'üêµ', options: ['üêµ', 'üêØ', 'ü¶ì'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏°‡∏µ '‡∏á‡∏ß‡∏á'?", a: 'üêò', options: ['üêº', 'üêò', 'ü¶Å'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏°‡∏µ‡∏•‡∏≤‡∏¢ '‡∏Ç‡∏≤‡∏ß-‡∏î‡∏≥'?", a: 'ü¶ì', options: ['ü¶ì', 'üêò', 'üêØ'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡πÄ‡∏õ‡πá‡∏ô '‡πÄ‡∏à‡πâ‡∏≤‡∏õ‡πà‡∏≤'?", a: 'ü¶Å', options: ['üêß', 'ü¶Å', 'ü¶ì'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏Å‡∏¥‡∏ô '‡πÑ‡∏ú‡πà' ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£?", a: 'üêº', options: ['üêµ', 'üêº', 'ü¶Å'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô '‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á'?", a: 'üêß', options: ['üêß', 'ü¶í', 'üêò'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏£‡πâ‡∏≠‡∏á '‡∏≠‡∏π‡πä‡∏î‡πÜ'?", a: 'üê∑', options: ['üê∑', 'üêÆ', 'üê∏'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô‡∏ä‡∏≠‡∏ö‡∏Å‡∏¥‡∏ô '‡∏ô‡∏°'?", a: 'üêÆ', options: ['üêÆ', 'üê∏', 'üê®'] },
                { q: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô '‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î' ‡πÄ‡∏Å‡πà‡∏á?", a: 'üê∏', options: ['üê∏', 'üê∑', 'üêÆ'] },
                // Math fallback
                { q: "1 + 1 ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö?", a: '2', options: ['1', '2', '3'] },
                { q: "5 - 2 ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö?", a: '3', options: ['2', '3', '4'] },
                { q: "2 x 2 ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö?", a: '4', options: ['2', '4', '6'] },
            ];

            const TOTAL_ROUNDS = 10; // Adjusted for better flow
            const [step, setStep] = useState('memorize');
            const [target, setTarget] = useState(null);
            const [distractCount, setDistractCount] = useState(0);
            const [options, setOptions] = useState([]);
            const [currentRound, setCurrentRound] = useState(1);
            const [timer, setTimer] = useState(10);
            const [currentQuiz, setCurrentQuiz] = useState(null);
            const [startTime, setStartTime] = useState(Date.now());

            // Level Scaling
            const effectiveLevel = Math.min(level, 15);
            const distractQCount = effectiveLevel <= 5 ? 1 : (effectiveLevel <= 10 ? 2 : 3);
            const recallOptionCount = effectiveLevel <= 5 ? 3 : (effectiveLevel <= 10 ? 4 : 6);

            useEffect(() => {
                startRound();
            }, []);

            // Timer for Memorize Phase
            useEffect(() => {
                if (step === 'memorize') {
                    if (timer > 0) {
                        const interval = setInterval(() => setTimer(t => t - 1), 1000);
                        return () => clearInterval(interval);
                    } else {
                        handleMemorized();
                    }
                }
            }, [step, timer]);

            const startRound = () => {
                const item = MEMORY_ITEMS[Math.floor(Math.random() * MEMORY_ITEMS.length)];
                setTarget(item);
                setStep('memorize');
                setTimer(10); // Reset timer to 10s
                setDistractCount(0);
                prepareDistraction();
            };

            const prepareDistraction = () => {
                const quiz = DISTRACTION_QUIZ_POOL[Math.floor(Math.random() * DISTRACTION_QUIZ_POOL.length)];
                const shuffledOptions = [...quiz.options].sort(() => 0.5 - Math.random());
                setCurrentQuiz({ ...quiz, options: shuffledOptions });
            };

            const handleMemorized = () => {
                setStep('distract');
            };

            const handleDistractAnswer = (selectedAns) => {
                if (selectedAns === currentQuiz.a) {
                    // Correct
                    if (distractCount + 1 < distractQCount) {
                        setDistractCount(prev => prev + 1);
                        prepareDistraction();
                    } else {
                        const others = MEMORY_ITEMS.filter(i => i.id !== target.id).sort(() => 0.5 - Math.random()).slice(0, recallOptionCount - 1);
                        setOptions([target, ...others].sort(() => 0.5 - Math.random()));
                        setStep('recall');
                    }
                } else {
                    alert('‡∏ú‡∏¥‡∏î‡∏Ñ‡∏£‡∏±‡∏ö ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
                }
            };

            const handleRecall = (selected) => {
                if (selected.id === target.id) {
                    if (currentRound < TOTAL_ROUNDS) {
                        setCurrentRound(p => p + 1);
                        startRound();
                    } else {
                        // Calc Score: Base 100 + Level Bonus
                        const roundScore = 100 * effectiveLevel;
                        const timeSpent = (Date.now() - startTime) / 1000;
                        updateStats(roundScore, timeSpent);
                        onComplete();
                    }
                } else {
                    alert('‡∏ú‡∏¥‡∏î‡∏Ñ‡∏£‡∏±‡∏ö ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
                    startRound();
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center justify-center p-6 bg-orange-50 h-full relative">
                    <div className="absolute top-4 right-4 bg-orange-200 text-orange-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Round {currentRound}/{TOTAL_ROUNDS}</div>

                    {step === 'memorize' && (
                        <div className="text-center animate-pop-in">
                            <h2 className="text-2xl font-bold mb-2 text-orange-800">‡∏à‡∏≥‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ</h2>
                            <div className="text-6xl font-black text-orange-400 mb-4">{timer}</div>
                            <div className="text-9xl mb-6 animate-pulse-custom">{target?.icon}</div>
                            <div className="text-3xl font-bold mb-8 text-slate-700">{target?.name}</div>
                            <p className="text-slate-400 text-sm">‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏î ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÑ‡∏õ‡∏ï‡πà‡∏≠‡πÄ‡∏≠‡∏á</p>
                        </div>
                    )}

                    {step === 'distract' && currentQuiz && (
                        <div className="text-center w-full max-w-md animate-fade-in">
                            <h2 className="text-xl font-bold mb-4 text-orange-800">‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Ñ‡∏±‡πà‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ ({distractCount + 1}/{distractQCount})</h2>
                            <div className="bg-white p-6 rounded-2xl shadow-sm mb-4 border-2 border-orange-100">
                                <p className="text-2xl font-bold text-slate-700">{currentQuiz.q}</p>
                            </div>
                            <div className="grid grid-cols-1 gap-3">
                                {currentQuiz.options.map((opt, i) => (
                                    <button key={i} onClick={() => handleDistractAnswer(opt)} className="py-4 bg-white rounded-xl shadow-sm font-bold text-2xl hover:bg-orange-100 border border-orange-50 transition active:scale-95">
                                        {opt}
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}

                    {step === 'recall' && (
                        <div className="text-center w-full animate-slide-up">
                            <h2 className="text-xl font-bold mb-6 text-orange-800">‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô?</h2>
                            <div className="grid grid-cols-2 gap-4">
                                {options.map(item => (
                                    <button key={item.id} onClick={() => handleRecall(item)} className="bg-white p-4 rounded-2xl shadow-sm flex flex-col items-center hover:bg-orange-50 active:scale-95 transition border border-orange-50">
                                        <span className="text-5xl mb-2">{item.icon}</span>
                                        <span className="font-bold text-slate-700">{item.name}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // ==========================================
        // GAME 2: VISUOSPATIAL
        // ==========================================
        function VisuospatialGame({ level, onComplete, onExit, updateStats }) {
            const [grid, setGrid] = useState([]);
            const [size, setSize] = useState(4);
            const [symmetryType, setSymmetryType] = useState('vertical');
            const [stage, setStage] = useState(1);
            const [startTime] = useState(Date.now()); // Track session start
            const TOTAL_STAGES = 15;

            // Level Scaling (Cap at 15)
            const effectiveLevel = Math.min(level, 15);

            useEffect(() => {
                const newSize = effectiveLevel <= 5 ? 4 : (effectiveLevel <= 10 ? 5 : 6);
                const count = Math.min(3 + Math.floor(effectiveLevel / 3), 8);
                setSize(newSize);
                generateLevel(newSize, count);
            }, [level, stage]);

            const generateLevel = useCallback(() => {
                let s = 4;
                let sym = 'vertical';
                let targetDots = 3;

                const difficultyFactor = level + Math.floor(stage / 3);

                if (difficultyFactor <= 5) {
                    s = 4;
                    sym = Math.random() > 0.5 ? 'vertical' : 'horizontal';
                    targetDots = 2 + Math.floor(difficultyFactor / 3);
                } else if (difficultyFactor <= 15) {
                    s = 4;
                    const types = ['vertical', 'horizontal', 'rotational-180'];
                    sym = types[Math.floor(Math.random() * types.length)];
                    targetDots = 4;
                } else {
                    s = Math.random() > 0.6 ? 6 : 4;
                    const types = ['vertical', 'horizontal', 'rotational-180', 'quadruple'];
                    sym = types[Math.floor(Math.random() * types.length)];
                    targetDots = Math.min(5 + Math.floor((difficultyFactor - 15) / 5), 8);
                }

                if (sym === 'quadruple') targetDots = Math.min(targetDots, Math.floor((s * s) / 4) - 1);
                else targetDots = Math.min(targetDots, Math.floor((s * s) / 2) - 1);

                setSize(s);
                setSymmetryType(sym);
                isProcessingWin.current = false;

                const newGrid = Array(s * s).fill(null).map((_, i) => ({
                    id: i,
                    row: Math.floor(i / s),
                    col: i % s,
                    isSource: false,
                    filled: false,
                    locked: false,
                }));

                const isValidSource = (r, c, type) => {
                    const half = s / 2;
                    if (type === 'vertical') return c < half;
                    if (type === 'horizontal') return r < half;
                    if (type === 'rotational-180') return r < half;
                    if (type === 'quadruple') return r < half && c < half;
                    return true;
                };

                let filledCount = 0;
                let attempts = 0;
                while (filledCount < targetDots && attempts < 200) {
                    attempts++;
                    const r = Math.floor(Math.random() * s);
                    const c = Math.floor(Math.random() * s);

                    if (isValidSource(r, c, sym)) {
                        const idx = r * s + c;
                        if (!newGrid[idx].locked) {
                            newGrid[idx].locked = true;
                            newGrid[idx].isSource = true;
                            filledCount++;
                        }
                    }
                }
                setGrid(newGrid);
            }, [level, stage]);

            const getReflection = (r, c, s, type) => {
                if (type === 'vertical') return [{ r: r, c: s - 1 - c }];
                if (type === 'horizontal') return [{ r: s - 1 - r, c: c }];
                if (type === 'rotational-180') return [{ r: s - 1 - r, c: s - 1 - c }];
                if (type === 'quadruple') {
                    return [
                        { r: r, c: s - 1 - c },
                        { r: s - 1 - r, c: c },
                        { r: s - 1 - r, c: s - 1 - c }
                    ];
                }
                return [];
            };

            const isProcessingWin = useRef(false);

            const handleCellClick = (idx) => {
                if (isProcessingWin.current) return;
                const cell = grid[idx];
                if (cell.locked) return;

                const newGrid = [...grid];
                newGrid[idx].filled = !newGrid[idx].filled;
                setGrid(newGrid);
                checkWinCondition(newGrid);
            };

            const checkWinCondition = (currentGrid) => {
                if (isProcessingWin.current) return;

                const idealGrid = Array(size * size).fill(false);

                currentGrid.forEach(cell => {
                    if (cell.locked) {
                        idealGrid[cell.id] = true;
                        const reflections = getReflection(cell.row, cell.col, size, symmetryType);
                        reflections.forEach(ref => {
                            const refIdx = ref.r * size + ref.c;
                            if (refIdx >= 0 && refIdx < idealGrid.length) idealGrid[refIdx] = true;
                        });
                    }
                });

                let isComplete = true;
                for (let i = 0; i < size * size; i++) {
                    const isFilled = currentGrid[i].locked || currentGrid[i].filled;
                    if (isFilled !== idealGrid[i]) {
                        isComplete = false;
                        break;
                    }
                }

                if (isComplete) {
                    isProcessingWin.current = true;
                    setTimeout(() => {
                        if (stage < TOTAL_STAGES) {
                            setStage(s => s + 1);
                        } else {
                            // Calc Score & Time
                            const roundScore = 150 * effectiveLevel;
                            const timeSpent = (Date.now() - startTime) / 1000;
                            updateStats(roundScore, timeSpent);
                            onComplete(null, { score: roundScore, time: timeSpent });
                        }
                    }, 300);
                }
            };

            const renderAxis = () => {
                const styleLine = "absolute bg-blue-400 opacity-50 pointer-events-none z-10 shadow-sm";
                const styleDot = "absolute bg-blue-500 rounded-full z-20 pointer-events-none transform -translate-x-1/2 -translate-y-1/2 shadow-md border-2 border-white animate-pulse-dot";

                switch (symmetryType) {
                    case 'vertical': return <div className={`${styleLine} left-1/2 top-0 bottom-0 w-1 -ml-0.5`} />;
                    case 'horizontal': return <div className={`${styleLine} top-1/2 left-0 right-0 h-1 -mt-0.5`} />;
                    case 'rotational-180': return <div className={`${styleDot} top-1/2 left-1/2 w-4 h-4`} />;
                    case 'quadruple': return (
                        <>
                            <div className={`${styleLine} left-1/2 top-0 bottom-0 w-1 -ml-0.5`} />
                            <div className={`${styleLine} top-1/2 left-0 right-0 h-1 -mt-0.5`} />
                        </>
                    );
                    default: return null;
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center justify-center p-6 bg-blue-50 h-full relative font-kanit">
                    <div className="absolute top-4 right-4 bg-blue-200 text-blue-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Stage {stage}/{TOTAL_STAGES}</div>

                    <div className="mb-6 px-4 py-2 rounded-full bg-white/60 backdrop-blur-md shadow-sm border border-white/50 text-sm font-bold text-slate-600 flex items-center gap-2">
                        {symmetryType === 'rotational-180' ? <Icon path={Icons.Refresh} size={14} /> : (symmetryType === 'quadruple' ? <Icon path={Icons.Grid4} size={14} /> : <div className="w-2 h-2 rounded-full bg-blue-500"></div>)}
                        <span>
                            {symmetryType === 'vertical' && "‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á"}
                            {symmetryType === 'horizontal' && "‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô"}
                            {symmetryType === 'rotational-180' && "‡∏™‡∏°‡∏°‡∏≤‡∏ï‡∏£ 180¬∞"}
                            {symmetryType === 'quadruple' && "‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô 4 ‡∏ó‡∏¥‡∏®"}
                        </span>
                    </div>

                    <div className="relative bg-white p-3 rounded-[2rem] shadow-xl border-4 border-white transition-all duration-300">
                        {renderAxis()}
                        <div className="grid gap-2 transition-all duration-300" style={{
                            gridTemplateColumns: `repeat(${size}, 1fr)`,
                            width: 'min(80vw, 340px)',
                            height: 'min(80vw, 340px)'
                        }}>
                            {grid.map((cell) => (
                                <button key={cell.id}
                                    onClick={() => handleCellClick(cell.id)}
                                    disabled={cell.locked}
                                    className={`relative rounded-xl transition-all duration-200 transform flex items-center justify-center
                                        ${cell.locked
                                            ? 'bg-slate-300 scale-95 shadow-inner'
                                            : (cell.filled
                                                ? 'bg-blue-500 scale-100 shadow-md text-white'
                                                : 'bg-slate-100 hover:bg-slate-200 active:scale-95')
                                        }`}
                                >
                                    {cell.locked && <div className="w-3 h-3 bg-white/30 rounded-full"></div>}
                                </button>
                            ))}
                        </div>
                    </div>

                    <button onClick={generateLevel} className="mt-8 flex items-center gap-2 text-slate-400 text-sm font-bold hover:text-blue-500 transition-colors">
                        <Icon path={Icons.RotateCcw} size={16} /> ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
                    </button>
                </div>
            );
        }

        // ==========================================
        // GAME 3: ATTENTION (New Zoo Feeder Logic)
        // ==========================================
        function AttentionGame({ level, onComplete, onExit, updateStats }) {
            const ANIMALS = [
                { emoji: 'ü¶Å', type: 'carn', name: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠', icon: 'ü•©' },
                { emoji: 'üêØ', type: 'carn', name: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠', icon: 'üçó' },
                { emoji: 'üêä', type: 'carn', name: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠', icon: 'üêü' },
                { emoji: 'üêò', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'üåø' },
                { emoji: 'ü¶í', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'üçÉ' },
                { emoji: 'üêá', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'ü•ï' },
                { emoji: 'ü¶ç', type: 'herb', name: '‡∏û‡∏∑‡∏ä', icon: 'üçå' }
            ];

            const FOOD_TYPES = {
                HERB: ['üåø', 'üçé', 'ü•ï', 'ü•¨', 'üåΩ', 'üçâ', 'üçå'],
                CARN: ['ü•©', 'üçó', 'ü•ì', 'üêü', 'üçñ', 'ü¶ê'],
                TRASH: ['üëü', 'üí£', 'ü•´', 'üß±', 'üß§', 'üì¶']
            };

            const BELT_POSITIONS = { 1: [50], 2: [30, 70], 3: [20, 50, 80] };

            // Progression Constants
            const POINTS_PER_LEVEL = 100;
            const POINTS_PER_ANIMAL_CHANGE = 500;

            // State
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [beltCount, setBeltCount] = useState(1);
            const [currentAnimals, setCurrentAnimals] = useState([]);
            const [foodItems, setFoodItems] = useState([]);
            const [gameActive, setGameActive] = useState(true);
            const [isPaused, setIsPaused] = useState(false);
            const [spawnRate, setSpawnRate] = useState(2000);
            const [speed, setSpeed] = useState(1.0);
            const [feedback, setFeedback] = useState(null);
            const [alertMsg, setAlertMsg] = useState(null);
            const [startTime] = useState(Date.now()); // Track start time

            // Dynamic Level based on Score
            const currentLevel = Math.floor(score / 300) + 1;

            // Refs for loop
            const requestRef = useRef();
            const lastSpawnTime = useRef(0);
            const foodItemsRef = useRef([]); // Sync with state
            const speedRef = useRef(2.0); // Sync with state
            const beltCountRef = useRef(1); // Sync with state
            const currentAnimalsRef = useRef([]); // Sync with state

            // Initialize
            useEffect(() => {
                startGame();
                return () => cancelAnimationFrame(requestRef.current);
            }, []);

            // Sync Refs
            useEffect(() => { foodItemsRef.current = foodItems; }, [foodItems]);
            useEffect(() => { speedRef.current = speed; }, [speed]);
            useEffect(() => { beltCountRef.current = beltCount; }, [beltCount]);
            useEffect(() => { currentAnimalsRef.current = currentAnimals; }, [currentAnimals]);

            const getRandomAnimal = () => ANIMALS[Math.floor(Math.random() * ANIMALS.length)];

            const generateAnimals = (count) => {
                const animals = [];
                for (let i = 0; i < count; i++) animals.push(getRandomAnimal());
                return animals;
            };

            const startGame = () => {
                const initialBeltCount = 1; // Always start easy
                const initialAnimals = generateAnimals(initialBeltCount);

                setScore(0);
                setLives(3);
                setBeltCount(initialBeltCount);
                setCurrentAnimals(initialAnimals);
                setFoodItems([]);
                setSpawnRate(1000);
                setSpeed(1.0);
                setGameActive(true);
                setIsPaused(false);

                lastSpawnTime.current = Date.now();
                requestRef.current = requestAnimationFrame(gameLoop);
            };

            const gameLoop = () => {
                if (!gameActive || isPaused) {
                    // Just keep loop alive but don't update if paused
                    if (gameActive && !isPaused) requestRef.current = requestAnimationFrame(gameLoop);
                    return;
                }

                const now = Date.now();

                // Spawn Logic
                // Balance: Divide base rate by belt count to maintain per-belt density
                const baseRate = 1500 - (speedRef.current * 400);
                const effectiveSpawnRate = Math.max(300, baseRate / beltCountRef.current);

                if (now - lastSpawnTime.current > effectiveSpawnRate) {
                    spawnFood();
                    lastSpawnTime.current = now;
                }

                // Move & Collision Logic
                updatePhysics();

                if (gameActive) requestRef.current = requestAnimationFrame(gameLoop);
            };

            const spawnFood = () => {
                const lanes = BELT_POSITIONS[beltCountRef.current];
                const laneIndex = Math.floor(Math.random() * lanes.length);
                const targetAnimal = currentAnimalsRef.current[laneIndex];

                if (!targetAnimal) return;


                const rand = Math.random();
                let type;
                if (rand < 0.25) type = 'trash';
                else if (rand < 0.6) type = targetAnimal.type === 'herb' ? 'carn' : 'herb'; // Wrong type
                else type = targetAnimal.type; // Correct type

                const list = type === 'trash' ? FOOD_TYPES.TRASH : (type === 'herb' ? FOOD_TYPES.HERB : FOOD_TYPES.CARN);
                const emoji = list[Math.floor(Math.random() * list.length)];

                const newItem = {
                    id: Date.now() + Math.random(),
                    emoji,
                    type,
                    laneIndex,
                    y: -50,
                    sorted: false
                };

                setFoodItems(prev => [...prev, newItem]);
            };

            const updatePhysics = () => {
                setFoodItems(prevItems => {
                    const nextItems = [];
                    // Using fixed threshold for collision since we can't easily get height ref in loop
                    const threshold = 650; // Approx bottom area

                    prevItems.forEach(item => {
                        if (item.sorted) return; // Skip sorted items (waiting for cleanup)

                        const newY = item.y + speedRef.current;

                        if (newY > threshold) {
                            handleReachAnimal(item);
                            // Item effectively removed from "active" physics
                        } else {
                            nextItems.push({ ...item, y: newY });
                        }
                    });
                    return nextItems;
                });
            };

            const handleReachAnimal = (item) => {
                const animal = currentAnimalsRef.current[item.laneIndex];
                const isCorrect = item.type === animal.type;

                if (isCorrect) {
                    addScore(20);
                    showFeedback('+20', item.laneIndex, '#10b981'); // Green
                } else {
                    deductLife();
                    const msg = item.type === 'trash' ? '‡∏Å‡∏¥‡∏ô‡∏Ç‡∏¢‡∏∞!' : '‡∏ú‡∏¥‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó!';
                    showFeedback(`${msg}`, item.laneIndex, '#ef4444'); // Red
                }
            };

            const handleItemClick = (item) => {
                if (item.sorted || isPaused) return;

                // Remove from active list immediately to prevent double clicks
                setFoodItems(prev => prev.filter(i => i.id !== item.id));

                const animal = currentAnimalsRef.current[item.laneIndex];
                const isCorrectFood = item.type === animal.type;

                // We are DISCARDING. 
                // Good discard = Trash OR Wrong Food (Not correct food)
                // Bad discard = Correct Food

                if (!isCorrectFood) {
                    addScore(10);
                    showFeedback('‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°!', item.laneIndex, '#fbbf24'); // Yellow
                } else {
                    deductLife();
                    showFeedback('‡∏ó‡∏¥‡πâ‡∏á‡∏ó‡∏≥‡πÑ‡∏°!', item.laneIndex, '#ef4444');
                }
            };

            const addScore = (points) => {
                setScore(prev => {
                    const newScore = prev + points;
                    checkProgression(prev, newScore);

                    // Check Level Completion (e.g. Target Score based on Hub Level)
                    // ENDLESS MODE: No target score check
                    /*
                    const targetScore = level * 200 + 200;
                    if (newScore >= targetScore) {
                        setGameActive(false);
                        onComplete();
                    }
                    */

                    return newScore;
                });
            };

            const deductLife = () => {
                setLives(prev => {
                    const newLives = prev - 1;
                    if (newLives <= 0) {
                        setGameActive(false);
                        const finalLevel = Math.floor(score / 300) + 1;
                        const timeSpent = (Date.now() - startTime) / 1000;
                        updateStats(score, timeSpent); // Save stats

                        // alert(`‡∏à‡∏ö‡πÄ‡∏Å‡∏°! ‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏ñ‡∏∂‡∏á Level ${finalLevel} (‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: ${score})`);
                        // Proceed to next game instead of exit
                        onComplete(finalLevel, { score: score, time: timeSpent });
                    }
                    return newLives;
                });
            };

            const checkProgression = (oldScore, newScore) => {
                // Check 1: Animal Change every 500
                if (Math.floor(newScore / 500) > Math.floor(oldScore / 500)) {
                    triggerAnimalChange();
                }

                // Check 2: Add Belt at 1000
                if (oldScore < 1000 && newScore >= 1000) {
                    triggerBeltUpdate(2);
                }
                // Check 3: Add Belt at 2500
                else if (oldScore < 2500 && newScore >= 2500) {
                    triggerBeltUpdate(3);
                }
            };

            const triggerAnimalChange = () => {
                setAlertMsg({ title: '‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏±‡∏ï‡∏ß‡πå!', sub: '‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô' });
                setTimeout(() => setAlertMsg(null), 1500);

                const count = beltCountRef.current;
                const laneToChange = Math.floor(Math.random() * count);

                setCurrentAnimals(prev => {
                    const next = [...prev];
                    next[laneToChange] = getRandomAnimal();
                    return next;
                });

                // Clear food only in that lane
                setFoodItems(prev => prev.filter(f => f.laneIndex !== laneToChange));
            };

            const triggerBeltUpdate = (newCount) => {
                setAlertMsg({ title: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≤‡∏¢‡∏û‡∏≤‡∏ô!', sub: `‡∏£‡∏∞‡∏î‡∏±‡∏ö ${newCount === 2 ? '‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ' : '‡πÇ‡∏õ‡∏£'} ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß` });
                setTimeout(() => setAlertMsg(null), 2000);

                setBeltCount(newCount);
                setCurrentAnimals(generateAnimals(newCount));

                // Reset everything for fairness
                setFoodItems([]);
                setSpeed(1.0); // Reset speed
                setSpawnRate(1000);
            };

            const showFeedback = (text, laneIndex, color) => {
                const pos = BELT_POSITIONS[beltCountRef.current][laneIndex];
                setFeedback({ text, left: `${pos}%`, color, id: Date.now() });
                setTimeout(() => setFeedback(null), 800);
            };

            // Restart Loop on state changes that affect ref logic (like Pause)
            useEffect(() => {
                if (gameActive && !isPaused) {
                    lastSpawnTime.current = Date.now();
                    requestRef.current = requestAnimationFrame(gameLoop);
                } else {
                    cancelAnimationFrame(requestRef.current);
                }
            }, [isPaused, gameActive]);

            return (
                <div className="flex-1 flex flex-col items-center relative overflow-hidden bg-zinc-900 font-kanit w-full h-full game-bg-dark">
                    {/* Background Pattern */}
                    <div className="absolute inset-0 opacity-10 pointer-events-none" style={{ backgroundImage: 'radial-gradient(#fff 2px, transparent 2px)', backgroundSize: '30px 30px' }}></div>

                    {/* HUD */}
                    <div className="w-full p-4 flex justify-between items-start z-50 pointer-events-none relative">
                        <div className="flex flex-col gap-2">
                            <div className="bg-white/90 text-slate-800 px-4 py-1 rounded-full font-bold shadow-lg flex items-center gap-2">
                                <span>‚≠ê</span> {score} <span className="text-slate-400 text-sm">| Best: Lv. {level}</span>
                            </div>
                            <div className="bg-white/90 text-blue-600 px-4 py-1 rounded-full font-bold shadow-lg flex items-center gap-2">
                                <span>‚ö°</span> ‡∏™‡∏≤‡∏¢‡∏û‡∏≤‡∏ô {beltCount}
                            </div>
                        </div>
                        <div className="flex flex-col gap-2 items-end pointer-events-auto">
                            <button onClick={() => setIsPaused(!isPaused)} className="bg-white text-slate-800 p-2 rounded-xl shadow-lg active:scale-95 transition">
                                <Icon path={isPaused ? Icons.Play : Icons.Pause} />
                            </button>
                            <div className="flex text-red-500 text-2xl drop-shadow-md">
                                {Array(Math.max(0, lives)).fill('‚ù§Ô∏è').map((_, i) => <span key={i}>‚ù§Ô∏è</span>)}
                            </div>
                        </div>
                    </div>

                    {/* ALERTS */}
                    {alertMsg && (
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white text-slate-800 px-8 py-6 rounded-3xl shadow-2xl z-[60] text-center w-3/4 animate-pop-in border-4 border-yellow-400">
                            <h2 className="text-3xl font-black mb-1 text-yellow-500">{alertMsg.title}</h2>
                            <p className="text-slate-500 font-bold">{alertMsg.sub}</p>
                        </div>
                    )}

                    {/* FEEDBACK */}
                    {feedback && (
                        <div className="absolute top-1/2 -translate-x-1/2 -translate-y-1/2 text-4xl font-black z-[60] animate-bounce-slow pointer-events-none whitespace-nowrap"
                            style={{ left: feedback.left, color: feedback.color, textShadow: '2px 2px 0 #fff' }}>
                            {feedback.text}
                        </div>
                    )}

                    {/* GAME AREA */}
                    <div className="relative w-full h-full max-w-md mx-auto flex-1">
                        {/* Belts & Animals */}
                        {BELT_POSITIONS[beltCount].map((pos, idx) => (
                            <React.Fragment key={idx}>
                                {/* Belt */}
                                <div className="absolute top-0 h-[80%] bg-slate-600 border-x-4 border-black/20 rounded-b-3xl shadow-xl overflow-hidden"
                                    style={{ left: `calc(${pos}% - ${beltCount === 3 ? '11%' : (beltCount === 2 ? '16%' : '22%')})`, width: beltCount === 3 ? '22%' : (beltCount === 2 ? '32%' : '45%') }}>
                                    <div className="w-full h-full opacity-20 belt-marking" style={{ animation: `moveBelt 1s linear infinite reverse` }}></div>
                                </div>

                                {/* Animal */}
                                <div className="absolute bottom-[20px] -translate-x-1/2 flex flex-col items-center z-20 transition-all duration-300"
                                    style={{ left: `${pos}%` }}>
                                    <div className="bg-white border-2 border-slate-100 px-3 py-1 rounded-full mb-1 shadow-sm text-slate-700 font-bold text-xs flex items-center gap-1 whitespace-nowrap">
                                        <span>{currentAnimals[idx]?.icon}</span> ‡∏Å‡∏¥‡∏ô{currentAnimals[idx]?.name}
                                    </div>
                                    <div className="text-[5rem] leading-none drop-shadow-xl filter">
                                        {currentAnimals[idx]?.emoji}
                                    </div>
                                </div>
                            </React.Fragment>
                        ))}

                        {/* Food Items */}
                        {foodItems.map(item => (
                            <div key={item.id}
                                onPointerDown={(e) => { e.stopPropagation(); handleItemClick(item); }}
                                className="absolute -translate-x-1/2 flex items-center justify-center text-[3.5rem] z-30 cursor-pointer select-none active:scale-90 transition-transform touch-manipulation"
                                style={{ left: `${BELT_POSITIONS[beltCount][item.laneIndex]}%`, top: item.y }}>
                                {item.emoji}
                            </div>
                        ))}
                    </div>

                    {/* Pause Overlay */}
                    {isPaused && (
                        <div className="absolute inset-0 bg-black/60 backdrop-blur-sm z-[70] flex items-center justify-center">
                            <div className="bg-white p-8 rounded-3xl text-center">
                                <h2 className="text-4xl font-black text-slate-800 mb-6">‡∏û‡∏±‡∏Å‡∏¢‡∏Å</h2>
                                <button onClick={() => setIsPaused(false)} className="w-full bg-green-500 text-white py-3 rounded-xl font-bold text-xl mb-3 shadow-lg">‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠</button>
                                <button onClick={onExit} className="w-full bg-slate-200 text-slate-600 py-3 rounded-xl font-bold text-xl">‡∏≠‡∏≠‡∏Å</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // ==========================================
        // GAME 4: LANGUAGE
        // ==========================================
        // ==========================================
        // GAME 4: LANGUAGE (Updated)
        // ==========================================
        function LanguageGame({ level, onComplete, onExit, updateStats }) {
            // Difficulty Levels
            const LANGUAGE_LEVELS = {
                EASY: [
                    { id: 1, q: 'üöó', type: 'image', correct: '‡∏£‡∏ñ', options: ['‡∏£‡∏ñ', '‡πÄ‡∏£‡∏∑‡∏≠', '‡∏£‡∏≤', '‡∏£‡∏î'] },
                    { id: 2, q: 'üè†', type: 'image', correct: '‡∏ö‡πâ‡∏≤‡∏ô', options: ['‡∏ö‡πâ‡∏≤‡∏ô', '‡∏ö‡∏≤‡∏ô', '‡∏ö‡πâ‡∏≤‡∏á', '‡∏ö‡πà‡∏≤‡∏á'] },
                    { id: 3, q: 'üê∂', type: 'image', correct: '‡∏´‡∏°‡∏≤', options: ['‡∏´‡∏°‡∏≤', '‡∏´‡∏°‡∏π', '‡∏´‡∏°‡∏µ', '‡πÅ‡∏°‡∏ß'] },
                    { id: 4, q: 'üß•', type: 'image', correct: '‡πÄ‡∏™‡∏∑‡πâ‡∏≠', options: ['‡πÄ‡∏™‡∏∑‡∏≠', '‡πÄ‡∏™‡∏∑‡πâ‡∏≠', '‡πÄ‡∏ä‡∏∑‡πâ‡∏≠', '‡∏™‡∏≤‡∏î'] },
                    { id: 5, q: 'üßä', type: 'image', correct: '‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', options: ['‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', '‡∏ô‡πâ‡∏≥‡πÅ‡∏Å‡∏á', '‡∏ô‡πâ‡∏≥‡∏Ç‡∏¥‡∏á', '‡∏ô‡πâ‡∏≥‡∏Ç‡∏≤‡∏ß'] },
                    { id: 101, q: 'üçå', type: 'image', correct: '‡∏Å‡∏•‡πâ‡∏ß‡∏¢', options: ['‡∏Å‡∏•‡πâ‡∏ß‡∏¢', '‡∏Å‡∏•‡∏ß‡∏¢', '‡∏Å‡∏ß‡∏¢', '‡∏™‡∏ß‡∏¢'] },
                    { id: 102, q: 'üö≤', type: 'image', correct: '‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô', options: ['‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô', '‡∏à‡∏±‡∏Å‡∏¢‡∏≤‡∏ô', '‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏•', '‡∏à‡∏±‡∏Å‡∏Å‡∏≤‡∏£'] },
                    { id: 103, q: 'üëì', type: 'image', correct: '‡πÅ‡∏ß‡πà‡∏ô', options: ['‡πÅ‡∏ß‡πà‡∏ô', '‡πÅ‡∏Ç‡∏ô', '‡πÅ‡∏Ñ‡πâ‡∏ô', '‡πÅ‡∏´‡∏ß‡∏ô'] },
                    { id: 104, q: 'üêò', type: 'image', correct: '‡∏ä‡πâ‡∏≤‡∏á', options: ['‡∏ä‡πâ‡∏≤‡∏á', '‡∏Ç‡πâ‡∏≤‡∏á', '‡∏Ñ‡πâ‡∏≤‡∏á', '‡∏Å‡∏≤‡∏á'] },
                    { id: 105, q: '‚òî', type: 'image', correct: '‡∏£‡πà‡∏°', options: ['‡∏£‡πà‡∏°', '‡∏•‡∏°', '‡∏•‡πà‡∏°', '‡∏à‡∏°'] },
                ],
                MEDIUM: [
                    { id: 6, q: 'üìÖ', text: '‡∏ß‡∏±‡∏ô...', type: 'abstract', correct: '‡∏®‡∏∏‡∏Å‡∏£‡πå', options: ['‡∏™‡∏∏‡∏Ç', '‡∏®‡∏∏‡∏Å‡∏£‡πå', '‡∏™‡∏∏‡∏Å', '‡∏®‡∏∏‡∏Å'] },
                    { id: 7, q: 'üòä', text: '‡∏Ñ‡∏ß‡∏≤‡∏°...', type: 'abstract', correct: '‡∏™‡∏∏‡∏Ç', options: ['‡∏®‡∏∏‡∏Å‡∏£‡πå', '‡∏™‡∏∏‡∏Ç', '‡∏™‡∏∏‡∏Å', '‡∏ó‡∏£‡∏∏‡∏Å'] },
                    { id: 8, q: 'ü•£', text: '‡πÉ‡∏™‡πà...', type: 'abstract', correct: '‡∏ö‡∏≤‡∏ï‡∏£', options: ['‡∏ö‡∏≤‡∏ó', '‡∏ö‡∏≤‡∏î', '‡∏ö‡∏±‡∏ï‡∏£', '‡∏ö‡∏≤‡∏ï‡∏£'] },
                    { id: 9, q: 'üí∞', text: '‡πÄ‡∏á‡∏¥‡∏ô...', type: 'abstract', correct: '‡∏ö‡∏≤‡∏ó', options: ['‡∏ö‡∏≤‡∏ó', '‡∏ö‡∏≤‡∏ï‡∏£', '‡∏ö‡∏≤‡∏î', '‡∏ö‡∏≤‡∏®'] },
                    { id: 10, q: 'ü™ú', text: '...‡∏ö‡∏±‡∏ô‡πÑ‡∏î', type: 'abstract', correct: '‡∏Ç‡∏±‡πâ‡∏ô', options: ['‡∏Ñ‡∏±‡πà‡∏ô', '‡∏Ç‡∏±‡πâ‡∏ô', '‡∏Ñ‡∏£‡∏±‡πâ‡∏ô', '‡∏Ñ‡∏±‡∏ô'] },
                    { id: 201, q: 'üî™', text: '‡∏°‡∏µ‡∏î...', type: 'abstract', correct: '‡∏ö‡∏≤‡∏î', options: ['‡∏ö‡∏≤‡∏ó', '‡∏ö‡∏≤‡∏î', '‡∏ö‡∏≤‡∏®', '‡∏ö‡∏≤‡∏ï‡∏£'] },
                    { id: 202, q: 'üåßÔ∏è', text: '‡πÇ‡∏≠‡∏Å‡∏≤‡∏™...', type: 'abstract', correct: '‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢', options: ['‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢', '‡∏≠‡∏≥‡∏ô‡∏ß‡∏ô', '‡∏≠‡∏≥‡∏£‡∏ß‡∏¢', '‡∏Å‡∏≥‡∏ô‡∏ß‡∏¢'] },
                    { id: 203, q: 'üå≤', text: '‡∏•‡∏≥...', type: 'abstract', correct: '‡∏ò‡∏≤‡∏£', options: ['‡∏ó‡∏≤‡∏ô', '‡∏ò‡∏≤‡∏£', '‡∏ò‡∏≤‡∏•', '‡∏°‡∏≤‡∏£'] },
                    { id: 204, q: 'üç≤', text: '‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞...', type: 'abstract', correct: '‡∏ó‡∏≤‡∏ô', options: ['‡∏ó‡∏≤‡∏ô', '‡∏ò‡∏≤‡∏£', '‡∏ó‡∏≤‡∏£', '‡∏Å‡∏≤‡∏£'] },
                    { id: 205, q: 'ü§í', text: '‡πÇ‡∏£‡∏Ñ...', type: 'abstract', correct: '‡∏†‡∏±‡∏¢', options: ['‡∏†‡∏±‡∏¢', '‡πÑ‡∏û', '‡πÑ‡∏û‡∏£', '‡πÉ‡∏†'] },
                ],
                HARD: [
                    { id: 11, q: 'üëÇ', text: '(‡∏£‡∏≤‡∏ä‡∏≤‡∏®‡∏±‡∏û‡∏ó‡πå)', type: 'royal', correct: '‡∏Å‡∏£‡∏£‡∏ì', options: ['‡∏Å‡∏£‡∏£‡∏ì', '‡∏Å‡∏±‡∏ô', '‡∏Å‡∏±‡∏ì‡∏ë‡πå', '‡∏Å‡∏£‡∏£'] },
                    { id: 12, q: 'üôÇ', text: '(‡∏£‡∏≤‡∏ä‡∏≤‡∏®‡∏±‡∏û‡∏ó‡πå)', type: 'royal', correct: '‡∏û‡∏±‡∏Å‡∏ï‡∏£‡πå', options: ['‡∏û‡∏±‡∏Å', '‡∏û‡∏±‡∏Ñ', '‡∏û‡∏±‡∏Å‡∏ï‡∏£‡πå', '‡∏†‡∏±‡∏Ñ'] },
                    { id: 13, q: 'üå≤', text: '(‡∏õ‡πà‡∏≤)', type: 'royal', correct: '‡∏û‡∏ô‡∏≤', options: ['‡∏û‡∏ô‡∏≤', '‡∏û‡∏≤', '‡∏û‡∏°‡∏≤', '‡∏ò‡∏ô‡∏≤'] },
                    { id: 14, q: 'üåä', text: '(‡∏ô‡πâ‡∏≥)', type: 'royal', correct: '‡∏ä‡∏•', options: ['‡∏ä‡∏ô', '‡∏ä‡∏•', '‡∏ã‡∏ô', '‡∏Å‡∏•'] },
                    { id: 15, q: '‚òÄÔ∏è', text: '(‡∏û‡∏£‡∏∞‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå)', type: 'royal', correct: '‡∏™‡∏∏‡∏£‡∏¥‡∏¢‡∏≤', options: ['‡∏™‡∏∏‡∏£‡∏¥‡∏¢‡∏≤', '‡∏™‡∏∏‡∏ô‡∏¥‡∏™‡∏≤', '‡∏™‡∏∏‡∏Å‡∏¥‡∏¢‡∏≤', '‡∏™‡∏∏‡∏ó‡∏¥‡∏ô'] },
                    { id: 301, q: 'üëÉ', text: '(‡∏£‡∏≤‡∏ä‡∏≤‡∏®‡∏±‡∏û‡∏ó‡πå)', type: 'royal', correct: '‡∏ô‡∏≤‡∏™‡∏¥‡∏Å', options: ['‡∏ô‡∏≤‡∏™‡∏¥‡∏Å', '‡∏ô‡∏≤‡∏™‡∏¥‡∏Ñ', '‡∏ô‡∏≤‡∏ã‡∏¥‡∏Å', '‡∏°‡∏≤‡∏™‡∏¥‡∏Å'] },
                    { id: 302, q: 'ü¶∂', text: '(‡∏£‡∏≤‡∏ä‡∏≤‡∏®‡∏±‡∏û‡∏ó‡πå)', type: 'royal', correct: '‡∏ö‡∏≤‡∏ó', options: ['‡∏ö‡∏≤‡∏ó', '‡∏ö‡∏≤‡∏ï', '‡∏ö‡∏≤‡∏®', '‡∏ö‡∏≤‡∏ô'] },
                    { id: 303, q: 'üåô', text: '(‡∏î‡∏ß‡∏á‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå)', type: 'royal', correct: '‡∏®‡∏®‡∏¥‡∏ò‡∏£', options: ['‡∏®‡∏®‡∏¥‡∏ò‡∏£', '‡∏®‡∏®‡∏¥‡∏ó‡∏£', '‡∏™‡∏™‡∏¥‡∏ò‡∏£', '‡∏®‡∏™‡∏¥‡∏ô‡∏≤'] },
                    { id: 304, q: 'üå∫', text: '(‡∏î‡∏≠‡∏Å‡πÑ‡∏°‡πâ)', type: 'royal', correct: '‡∏ö‡∏∏‡∏õ‡∏ú‡∏≤', options: ['‡∏ö‡∏∏‡∏õ‡∏ú‡∏≤', '‡∏ö‡∏∏‡∏ö‡∏ú‡∏≤', '‡∏ö‡∏∏‡∏û‡∏û‡∏≤', '‡∏ö‡∏∏‡∏©‡∏ö‡∏≤'] },
                    { id: 305, q: '‚õ∞Ô∏è', text: '(‡∏†‡∏π‡πÄ‡∏Ç‡∏≤)', type: 'royal', correct: '‡∏ö‡∏£‡∏£‡∏û‡∏ï', options: ['‡∏ö‡∏£‡∏£‡∏û‡∏ï', '‡∏ö‡∏£‡∏£‡∏û‡∏ï', '‡∏ö‡∏±‡∏ô‡∏û‡∏ï', '‡∏ö‡∏±‡∏ç‡∏û‡∏ï'] },
                ]
            };





            // Combine all for easy access or keep separated
            // Better: use a large pool defined outside or memoized

            const [currentQ, setCurrentQ] = useState(null);
            const [stage, setStage] = useState(1);
            const [startTime, setStartTime] = useState(Date.now());
            const [usedQuestions, setUsedQuestions] = useState([]); // Track used IDs
            const TOTAL_STAGES = 10;

            useEffect(() => {
                // Pre-load pools if needed, or just run generate
                generateQuestion();
            }, [level, stage]);

            const generateQuestion = () => {
                let pool = [];
                if (level <= 5) pool = LANGUAGE_LEVELS.EASY || [];
                else if (level <= 10) pool = LANGUAGE_LEVELS.MEDIUM || [];
                else pool = LANGUAGE_LEVELS.HARD || [];

                // Filter out used
                const available = pool.filter(p => !usedQuestions.includes(p.id));

                // If run out, reset used for this session (or just pick random)
                let q;
                if (available.length > 0) {
                    q = available[Math.floor(Math.random() * available.length)];
                } else {
                    // Reset or pick any
                    q = pool[Math.floor(Math.random() * pool.length)];
                }

                if (!q) return; // Safeguard

                setUsedQuestions(prev => [...prev, q.id]);

                // Shuffle options for display
                const shuffledOpts = [...q.options].sort(() => 0.5 - Math.random());
                setCurrentQ({ ...q, displayOptions: shuffledOpts });
            };

            const handleAnswer = (ans) => {
                if (ans === currentQ.correct) {
                    if (stage < TOTAL_STAGES) {
                        setStage(s => s + 1);
                    } else {
                        // Calc Score
                        const roundScore = 100 * level;
                        const timeSpent = (Date.now() - startTime) / 1000;
                        updateStats(roundScore, timeSpent);
                        onComplete(null, { score: roundScore, time: timeSpent });
                    }
                } else {
                    alert('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö');
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center justify-center p-6 bg-purple-50 h-full relative">
                    <div className="absolute top-4 right-4 bg-purple-200 text-purple-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Stage {stage}/{TOTAL_STAGES}</div>

                    <div className="bg-white p-6 rounded-3xl shadow-lg text-center w-full mb-6 border-b-4 border-purple-200">
                        <span className="text-sm text-slate-400 font-bold uppercase">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á</span>

                        <div className="mt-4 mb-2 flex flex-col items-center">
                            <span className="text-8xl filter drop-shadow-md">{currentQ?.q}</span>
                            {currentQ?.text && <span className="text-xl text-slate-500 font-bold mt-2">{currentQ?.text}</span>}
                        </div>
                    </div>

                    <div className="grid grid-cols-2 gap-4 w-full">
                        {currentQ?.displayOptions.map((ans, i) => (
                            <button key={i} onClick={() => handleAnswer(ans)} className="bg-white border-2 border-purple-100 py-6 rounded-2xl text-2xl font-bold text-purple-700 hover:bg-purple-500 hover:text-white hover:border-purple-500 transition active:scale-95 shadow-sm">
                                {ans}
                            </button>
                        ))}
                    </div>
                </div>
            );
        }

        // ==========================================
        // GAME 5: EXECUTIVE (Updated Logic)
        // ==========================================
        function ExecutiveGame({ level, onComplete, onExit, updateStats }) {
            const ALL_ANIMALS = ['ü¶Å', 'üêò', 'ü¶í', 'üêí', 'ü¶ì', 'üêØ', 'ü¶õ', 'üêº', 'ü¶ä', 'üê®', 'üêÆ', 'üê∑', 'üê∏', 'üêî', 'üêß'];

            const [grid, setGrid] = useState([]);
            const [solution, setSolution] = useState([]);
            const [rows, setRows] = useState(1);
            const [cols, setCols] = useState(3);
            const [hints, setHints] = useState([]);
            const [availableAnimals, setAvailableAnimals] = useState([]);
            const [selectedAnimal, setSelectedAnimal] = useState(null);
            const [stage, setStage] = useState(1);
            const [startTime] = useState(Date.now());
            const TOTAL_STAGES = 15;

            // Level Scaling (Cap difficulty logic at level 15)
            const effectiveLevel = Math.min(level, 15);

            useEffect(() => {
                initLevel();
            }, [level, stage]);

            const initLevel = () => {
                let r = 1, c = 3;
                if (effectiveLevel >= 4 && effectiveLevel <= 6) { r = 2; c = 3; } // 6 slots
                else if (effectiveLevel >= 7) { r = 3; c = 3; } // 9 slots

                // For level 2-3, use 2x2 for variety
                if (effectiveLevel === 2 || effectiveLevel === 3) { r = 2; c = 2; }

                setRows(r);
                setCols(c);

                const totalSlots = r * c;
                const roundAnimals = [...ALL_ANIMALS].sort(() => Math.random() - 0.5).slice(0, totalSlots);

                setAvailableAnimals(roundAnimals);
                const sol = [...roundAnimals].sort(() => Math.random() - 0.5);
                setSolution(sol);
                setGrid(new Array(totalSlots).fill(null));

                generateHints(sol, r, c);
            };

            const getPosName = (idx, r, c) => {
                const row = Math.floor(idx / c);
                const col = idx % c;

                // 1x3: ‡∏ã‡πâ‡∏≤‡∏¢, ‡∏Å‡∏•‡∏≤‡∏á, ‡∏Ç‡∏ß‡∏≤
                if (r === 1) {
                    if (c === 3) return ["‡∏ä‡πà‡∏≠‡∏á‡∏ã‡πâ‡∏≤‡∏¢", "‡∏ä‡πà‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á", "‡∏ä‡πà‡∏≠‡∏á‡∏Ç‡∏ß‡∏≤"][col];
                    return col === 0 ? "‡∏ã‡πâ‡∏≤‡∏¢" : "‡∏Ç‡∏ß‡∏≤";
                }

                // 2x2: ‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢, ‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏Ç‡∏ß‡∏≤, ‡∏Ø‡∏•‡∏Ø
                if (r === 2 && c === 2) {
                    const v = row === 0 ? "‡∏ö‡∏ô" : "‡∏•‡πà‡∏≤‡∏á";
                    const h = col === 0 ? "‡∏ã‡πâ‡∏≤‡∏¢" : "‡∏Ç‡∏ß‡∏≤";
                    return `‡∏°‡∏∏‡∏°${v}${h}`;
                }

                // 2x3 & 3x3: ‡πÅ‡∏ñ‡∏ß‡∏ö‡∏ô/‡∏•‡πà‡∏≤‡∏á + ‡∏ã‡πâ‡∏≤‡∏¢/‡∏Å‡∏•‡∏≤‡∏á/‡∏Ç‡∏ß‡∏≤
                const vNames = r === 2 ? ["‡∏ö‡∏ô", "‡∏•‡πà‡∏≤‡∏á"] : ["‡∏ö‡∏ô", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏•‡πà‡∏≤‡∏á"];
                const hNames = ["‡∏ã‡πâ‡∏≤‡∏¢", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏Ç‡∏ß‡∏≤"];

                // Construct simpler names
                // e.g. "‡πÅ‡∏ñ‡∏ß‡∏ö‡∏ô ‡∏ä‡πà‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á" or "‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢" if it's a corner
                const vName = vNames[row];
                const hName = hNames[col];

                if (hName === "‡∏Å‡∏•‡∏≤‡∏á") return `‡πÅ‡∏ñ‡∏ß${vName} ‡∏ä‡πà‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á`;
                if (vName === "‡∏Å‡∏•‡∏≤‡∏á") return `‡πÅ‡∏ñ‡∏ß‡∏Å‡∏•‡∏≤‡∏á ‡∏ä‡πà‡∏≠‡∏á${hName}`;

                return `‡∏°‡∏∏‡∏°${vName}${hName}`; // e.g., ‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢
            };

            const generateHints = (sol, r, c) => {
                const total = r * c;
                const newHints = [];
                const visited = new Set();

                // 1. Reveal one anchor position (usually a corner or edge)
                const startIdx = Math.floor(Math.random() * total);
                visited.add(startIdx);
                newHints.push({ text: `üìç ${sol[startIdx]} ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà ${getPosName(startIdx, r, c)}` });

                // 2. Generate relative hints until all connected
                let attempts = 0;
                while (visited.size < total && attempts < 100) {
                    attempts++;
                    // Pick a visited node to branch from
                    const u = [...visited][Math.floor(Math.random() * visited.size)];
                    const uRow = Math.floor(u / c);
                    const uCol = u % c;

                    const neighbors = [
                        { idx: u - c, dir: 'up', valid: uRow > 0 },
                        { idx: u + c, dir: 'down', valid: uRow < r - 1 },
                        { idx: u - 1, dir: 'left', valid: uCol > 0 },
                        { idx: u + 1, dir: 'right', valid: uCol < c - 1 }
                    ].filter(n => n.valid);

                    if (neighbors.length === 0) continue;

                    const target = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const v = target.idx;

                    if (!visited.has(v) || Math.random() > 0.8) {
                        const a1 = sol[u]; // Reference animal (Known)
                        const a2 = sol[v]; // Target animal (Unknown)

                        let txt = "";
                        // Describe A2 relative to A1
                        if (target.dir === 'up') txt = `üîº ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á ${a1}`;
                        if (target.dir === 'down') txt = `üîΩ ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á ${a1}`;
                        if (target.dir === 'left') txt = `üëà ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á ${a1}`;
                        if (target.dir === 'right') txt = `üëâ ${a2} ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á ${a1}`;

                        // Check for duplicates
                        if (!newHints.some(h => h.text === txt)) {
                            newHints.push({ text: txt });
                            visited.add(v);
                        }
                    }
                }
                setHints(newHints);
            };

            const handleSlotClick = (idx) => {
                if (!selectedAnimal) return;

                // Move animal if already placed
                const currentIdx = grid.indexOf(selectedAnimal);
                const newGrid = [...grid];
                if (currentIdx !== -1) newGrid[currentIdx] = null;

                newGrid[idx] = selectedAnimal;
                setGrid(newGrid);
            };

            const checkAnswer = () => {
                if (grid.some(x => x === null)) {
                    alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á");
                    return;
                }
                const isCorrect = grid.every((val, i) => val === solution[i]);
                if (isCorrect) {
                    if (stage < TOTAL_STAGES) {
                        setStage(s => s + 1);
                    } else {
                        // Calc Score
                        const roundScore = 120 * effectiveLevel;
                        const timeSpent = (Date.now() - startTime) / 1000;
                        updateStats(roundScore, timeSpent);
                        onComplete(null, { score: roundScore, time: timeSpent });
                    }
                } else {
                    alert("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å ‡∏•‡∏≠‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞");
                }
            };

            return (
                <div className="flex-1 flex flex-col items-center p-4 bg-rose-50 h-full relative">
                    <div className="absolute top-4 right-4 bg-rose-200 text-rose-800 px-3 py-1 rounded-full font-bold">Level {level}</div>
                    <div className="absolute top-4 left-4 text-slate-500 font-bold">Stage {stage}/{TOTAL_STAGES}</div>

                    {/* Hints */}
                    <div className="bg-white rounded-2xl p-4 shadow-sm border-2 border-rose-200 mb-4 w-full max-h-[35%] overflow-y-auto">
                        <h2 className="font-bold text-rose-800 mb-2 flex items-center gap-2"><span className="text-xl">üïµÔ∏è</span> ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏™‡∏∑‡∏ö</h2>
                        <ul className="space-y-2 text-sm font-medium text-slate-600">
                            {hints.map((h, i) => (
                                <li key={i} className="pl-2 border-l-4 border-rose-100">{h.text}</li>
                            ))}
                        </ul>
                    </div>

                    {/* Grid */}
                    <div className="flex-1 flex items-center justify-center min-h-0 w-full">
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: `repeat(${cols}, 1fr)`,
                            gap: '8px',
                            width: '100%',
                            maxWidth: '350px',
                            aspectRatio: `${cols}/${rows}`
                        }}>
                            {grid.map((animal, i) => (
                                <div key={i} onClick={() => handleSlotClick(i)}
                                    className={`relative bg-white rounded-xl border-2 border-rose-100 flex items-center justify-center text-4xl shadow-sm transition-all active:scale-95 cursor-pointer ${animal ? 'border-rose-400 bg-rose-50' : ''}`}>
                                    <span className="absolute top-1 left-2 text-[10px] text-slate-300 font-bold">{i + 1}</span>
                                    {animal}
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="bg-white p-4 w-full rounded-2xl shadow-sm border border-rose-100 mt-4">
                        <div className="flex justify-center gap-2 mb-4 flex-wrap">
                            {availableAnimals.map(animal => (
                                <button key={animal}
                                    onClick={() => setSelectedAnimal(animal)}
                                    className={`w-12 h-12 rounded-lg text-2xl flex items-center justify-center border-2 transition-all ${selectedAnimal === animal ? 'border-rose-500 bg-rose-100 -translate-y-1 shadow-md' : 'border-slate-200 bg-slate-50'}`}>
                                    {animal}
                                </button>
                            ))}
                        </div>
                        <button onClick={checkAnswer} className="w-full bg-rose-500 text-white font-bold py-3 rounded-xl shadow-md active:scale-95 transition">
                            ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö
                        </button>
                    </div>
                </div>
            );
        }

        // ==========================================
        // WELCOME SCREEN
        // ==========================================
        const WelcomeScreen = ({ onStart, onShowLeaderboard }) => (
            <div className="w-full h-full flex flex-col items-center justify-center bg-emerald-50 relative overflow-hidden font-kanit p-6">
                {/* Decorative Background */}
                <div className="absolute top-[-10%] right-[-10%] w-64 h-64 bg-emerald-200 rounded-full blur-3xl opacity-50 animate-pulse-custom"></div>
                <div className="absolute bottom-[-10%] left-[-10%] w-64 h-64 bg-yellow-200 rounded-full blur-3xl opacity-50 animate-pulse-custom" style={{ animationDelay: '1s' }}></div>

                <div className="z-10 flex flex-col items-center text-center">
                    <div className="bg-white p-8 rounded-[3rem] shadow-xl mb-8 animate-pop-in border-4 border-emerald-100">
                        <div className="text-8xl mb-4 animate-bounce-slow">ü¶Å</div>
                        <h1 className="text-4xl font-black text-emerald-800 tracking-tight leading-tight">
                            Zoo<br /><span className="text-emerald-500">Brain Fit</span>
                        </h1>
                    </div>

                    <p className="text-slate-500 text-lg mb-12 font-medium max-w-[250px] animate-slide-up">
                        ‡∏ù‡∏∂‡∏Å‡∏™‡∏°‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏•‡∏≠‡∏á‡∏õ‡∏±‡∏ç‡∏ç‡∏≤<br />‡πÑ‡∏õ‡∏Å‡∏±‡∏ö‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ô‡πà‡∏≤‡∏£‡∏±‡∏Å
                    </p>

                    <button
                        onClick={onStart}
                        className="w-full max-w-xs bg-emerald-600 hover:bg-emerald-700 text-white text-2xl font-black py-5 rounded-2xl shadow-xl shadow-emerald-200 transform transition-all active:scale-95 flex items-center justify-center gap-3 animate-slide-up"
                    >
                        <Icon path={Icons.Play} size={28} fill="currentColor" />
                        ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
                    </button>
                </div>

                <div className="absolute bottom-6 text-slate-400 text-xs font-bold opacity-60">
                    v1.7.0 ‚Ä¢ Zoo Edition + Refined Flow
                </div>

                {/* Leaderboard Button (Moved here) */}
                <button
                    onClick={() => onShowLeaderboard()}
                    className="absolute top-6 right-6 p-3 rounded-full bg-white/50 hover:bg-white text-emerald-800 transition shadow-lg backdrop-blur-sm animate-fade-in"
                >
                    <Icon path={Icons.Trophy} size={24} />
                </button>
            </div>
        );

        // ==========================================
        // GAME SUMMARY SCREEN (New)
        // ==========================================
        const GameSummaryScreen = ({ gameName, score, level, time, onNext, onHome }) => (
            <div className="w-full h-full flex flex-col items-center justify-center bg-emerald-50 relative overflow-hidden font-kanit p-6">
                {/* Decorative Background */}
                <div className="absolute top-0 left-0 w-full h-full bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMSIgY3k9IjEiIHI9IjEiIGZpbGw9IiMxMGI5ODEiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] opacity-50"></div>

                <div className="z-10 w-full max-w-md bg-white rounded-[2.5rem] p-8 shadow-2xl text-center border-4 border-emerald-100 animate-pop-in">
                    <div className="text-6xl mb-4 animate-bounce">üéâ</div>
                    <h1 className="text-3xl font-black text-slate-800 mb-2">‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!</h1>
                    <p className="text-slate-500 font-bold mb-8">‡πÄ‡∏Å‡∏° {gameName}</p>

                    <div className="grid grid-cols-2 gap-4 mb-8">
                        <div className="bg-yellow-50 p-4 rounded-2xl border border-yellow-100">
                            <div className="text-sm text-yellow-600 font-bold uppercase">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</div>
                            <div className="text-4xl font-black text-yellow-500">{score}</div>
                        </div>
                        <div className="bg-blue-50 p-4 rounded-2xl border border-blue-100">
                            <div className="text-sm text-blue-600 font-bold uppercase">‡∏£‡∏∞‡∏î‡∏±‡∏ö</div>
                            <div className="text-4xl font-black text-blue-500">{level}</div>
                        </div>
                    </div>

                    <div className="bg-slate-50 p-3 rounded-xl border border-slate-100 mb-6 flex items-center justify-center gap-2 text-slate-500 font-bold">
                        <Icon path={Icons.Clock} size={20} />
                        <span>‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ: {Math.floor(time || 0)} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ</span>
                    </div>

                    <div className="flex flex-col gap-3">
                        <button onClick={onNext} className="w-full bg-emerald-500 hover:bg-emerald-600 text-white py-4 rounded-xl font-bold text-xl shadow-lg active:scale-95 transition flex items-center justify-center gap-2">
                            ‡∏î‡πà‡∏≤‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ <Icon path={Icons.ChevronRight} />
                        </button>
                        <button onClick={onHome} className="w-full bg-slate-100 hover:bg-slate-200 text-slate-600 py-3 rounded-xl font-bold active:scale-95 transition">
                            ‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å
                        </button>
                    </div>
                </div>
            </div>
        );

        // ==========================================
        // LEADERBOARD SCREEN
        // ==========================================
        function LeaderboardScreen({ onClose, history = [], games }) {
            const [activeTab, setActiveTab] = useState('all');

            // Filter history
            const filteredHistory = history.filter(h => {
                if (activeTab === 'all') return true;
                return h.gameId === activeTab;
            }).sort((a, b) => b.timestamp - a.timestamp); // Newest first

            const formatDate = (ts) => {
                return new Date(ts).toLocaleString('th-TH', {
                    day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit'
                });
            };

            return (
                <div className="w-full h-full flex flex-col bg-emerald-50 font-kanit">
                    {/* Header */}
                    <div className="bg-white p-4 shadow-sm z-10 flex items-center justify-between rounded-b-3xl">
                        <div className="flex items-center gap-3">
                            <div className="bg-yellow-100 p-2 rounded-xl text-yellow-600">
                                <Icon path={Icons.Trophy} size={24} />
                            </div>
                            <div>
                                <h2 className="text-xl font-black text-slate-800">‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</h2>
                                <p className="text-xs text-slate-400">‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
                            </div>
                        </div>
                        <button onClick={onClose} className="p-2 bg-slate-100 rounded-full text-slate-500 hover:bg-slate-200 transition">
                            <Icon path={Icons.X} size={20} />
                        </button>
                    </div>

                    {/* Tabs */}
                    <div className="flex gap-2 p-4 overflow-x-auto no-scrollbar">
                        <button
                            onClick={() => setActiveTab('all')}
                            className={`px-4 py-2 rounded-full text-sm font-bold whitespace-nowrap transition-all ${activeTab === 'all' ? 'bg-emerald-600 text-white shadow-md' : 'bg-white text-slate-500'}`}
                        >
                            ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                        </button>
                        {Object.values(games).map(g => (
                            <button
                                key={g.id}
                                onClick={() => setActiveTab(g.id)}
                                className={`px-4 py-2 rounded-full text-sm font-bold whitespace-nowrap transition-all flex items-center gap-1 ${activeTab === g.id ? 'bg-emerald-600 text-white shadow-md' : 'bg-white text-slate-500'}`}
                            >
                                <span>{g.icon}</span> {g.name}
                            </button>
                        ))}
                    </div>

                    {/* List */}
                    <div className="flex-1 overflow-y-auto px-4 pb-20 space-y-3">
                        {filteredHistory.length === 0 ? (
                            <div className="flex flex-col items-center justify-center h-64 text-slate-400 opacity-60">
                                <Icon path={Icons.Trophy} size={48} className="mb-2" />
                                <p>‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô</p>
                            </div>
                        ) : (
                            filteredHistory.map((record, i) => {
                                const game = games[record.gameId];
                                return (
                                    <div key={i} className="bg-white p-4 rounded-2xl shadow-sm border border-slate-100 flex items-center gap-4 animate-slide-up" style={{ animationDelay: `${i * 0.05}s` }}>
                                        <div className={`w-12 h-12 rounded-xl flex items-center justify-center text-2xl shrink-0 ${game?.color.replace('text-', 'bg-').split(' ')[0] || 'bg-slate-100'}`}>
                                            {game?.icon}
                                        </div>
                                        <div className="flex-1 min-w-0">
                                            <div className="flex justify-between items-start">
                                                <h3 className="font-bold text-slate-700 truncate">{game?.name}</h3>
                                                <span className="text-emerald-600 font-extrabold text-lg">+{record.score}</span>
                                            </div>
                                            <div className="flex justify-between items-center mt-1">
                                                <div className="flex items-center gap-2 text-xs text-slate-400 font-medium">
                                                    <Icon path={Icons.Clock} size={12} />
                                                    <span>{formatDate(record.timestamp)}</span>
                                                </div>
                                                <div className="text-xs font-bold bg-slate-100 text-slate-500 px-2 py-0.5 rounded-lg">
                                                    {Math.floor(record.duration)} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })
                        )}
                    </div>
                </div>
            );
        }

        // ==========================================
        // MAIN APP COMPONENT
        // ==========================================
        // ==========================================
        // MAIN APP COMPONENT (Updated)
        // ==========================================
        function App() {
            // STATE with V2 Storage
            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem('zoo_brain_v2');
                const parsed = saved ? JSON.parse(saved) : {};

                return {
                    progress: parsed.progress || { memory: 1, visuospatial: 1, attention: 1, language: 1, executive: 1 },
                    highScores: parsed.highScores || { memory: 0, visuospatial: 0, attention: 0, language: 0, executive: 0 },
                    playTime: parsed.playTime || { memory: 0, visuospatial: 0, attention: 0, language: 0, executive: 0 },
                    history: parsed.history || [] // New: History tracking
                };
            });

            const [selectedGames, setSelectedGames] = useState([]);
            const [activeGameIndex, setActiveGameIndex] = useState(null);
            const [screen, setScreen] = useState('welcome');
            const [showExitConfirm, setShowExitConfirm] = useState(false);
            const [lastGameResult, setLastGameResult] = useState(null); // { score, level, gameName }

            useEffect(() => {
                localStorage.setItem('zoo_brain_v2', JSON.stringify(gameState));
            }, [gameState]);

            // Handlers
            const toggleSelection = (gameId) => {
                if (selectedGames.includes(gameId)) {
                    setSelectedGames(prev => prev.filter(id => id !== gameId));
                } else {
                    if (selectedGames.length < 3) {
                        setSelectedGames(prev => [...prev, gameId]);
                    }
                }
            };

            const resetProgress = (gameId, e) => {
                e.stopPropagation();
                if (confirm(`‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á ${GAMES[gameId].name} ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î?`)) {
                    setGameState(prev => ({
                        ...prev,
                        progress: { ...prev.progress, [gameId]: 1 },
                        highScores: { ...prev.highScores, [gameId]: 0 },
                        playTime: { ...prev.playTime, [gameId]: 0 }
                    }));
                }
            };

            const startSession = () => {
                if (selectedGames.length === 3) {
                    setActiveGameIndex(0);
                    setScreen('playing');
                }
            };

            const handleUpdateStats = (gameId, score, timeInSeconds) => {
                setGameState(prev => {
                    const newHigh = Math.max(prev.highScores[gameId], score);
                    const newTime = prev.playTime[gameId] + timeInSeconds;

                    // Add new record to history
                    const newRecord = {
                        gameId,
                        score,
                        duration: timeInSeconds,
                        timestamp: Date.now()
                    };

                    const newHistory = [newRecord, ...(prev.history || [])].slice(0, 100); // Keep last 100 records

                    return {
                        ...prev,
                        highScores: { ...prev.highScores, [gameId]: newHigh },
                        playTime: { ...prev.playTime, [gameId]: newTime },
                        history: newHistory
                    };
                });
            };

            const handleLevelComplete = (achievedLevel, finalScoreObj) => {
                const currentGameId = selectedGames[activeGameIndex];

                let sessionScore = 0;
                let sessionTime = 0;

                if (typeof finalScoreObj === 'object' && finalScoreObj !== null) {
                    sessionScore = finalScoreObj.score;
                    sessionTime = finalScoreObj.time;
                } else {
                    sessionScore = finalScoreObj || 0;
                }

                // Update Progress Level
                setGameState(prev => {
                    let nextLv = prev.progress[currentGameId];
                    if (achievedLevel) nextLv = Math.max(nextLv, achievedLevel);
                    else nextLv = nextLv + 1;

                    return {
                        ...prev,
                        progress: { ...prev.progress, [currentGameId]: nextLv }
                    };
                });

                // Set Result for Summary
                setLastGameResult({
                    score: sessionScore,
                    level: achievedLevel || gameState.progress[currentGameId],
                    time: sessionTime,
                    gameName: GAMES[currentGameId].name
                });

                setScreen('summary');
            };

            const handleNextGame = () => {
                if (activeGameIndex !== null && activeGameIndex < selectedGames.length - 1) {
                    setActiveGameIndex(prev => prev + 1);
                    setScreen('playing');
                } else {
                    // All Done
                    alert("üéâ ‡∏à‡∏ö‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡∏Ñ‡∏£‡∏ö 3 ‡πÄ‡∏Å‡∏°‡πÅ‡∏•‡πâ‡∏ß!");
                    setScreen('selection');
                    setActiveGameIndex(null);
                    setSelectedGames([]);
                }
            };

            const exitSession = () => {
                setShowExitConfirm(true);
            };

            const confirmExitSession = () => {
                setShowExitConfirm(false);
                setScreen('selection');
                setActiveGameIndex(null);
            };

            const handleWelcomeStart = () => {
                setScreen('selection');
            };

            // RENDER SCREEN
            if (screen === 'welcome') {
                return <WelcomeScreen onStart={handleWelcomeStart} onShowLeaderboard={() => setScreen('leaderboard')} />;
            }

            if (screen === 'leaderboard') {
                return (
                    <LeaderboardScreen
                        onClose={() => setScreen('welcome')}
                        history={gameState.history}
                        games={GAMES}
                    />
                );
            }

            if (screen === 'summary' && lastGameResult) {
                return (
                    <GameSummaryScreen
                        gameName={lastGameResult.gameName}
                        score={lastGameResult.score}
                        level={lastGameResult.level}
                        time={lastGameResult.time}
                        onNext={handleNextGame}
                        onHome={confirmExitSession}
                    />
                );
            }

            if (screen === 'playing') {
                if (activeGameIndex === null || !selectedGames[activeGameIndex]) {
                    // Safeguard if activeGameIndex is invalid
                    return <div className="w-full h-full flex items-center justify-center">Loading...</div>;
                }
                const currentGameId = selectedGames[activeGameIndex];
                const gameData = GAMES[currentGameId];

                // Safety check for game data
                if (!gameData) {
                    return <div className="w-full h-full flex items-center justify-center">Error: Game Data Not Found</div>;
                }

                const currentLevel = gameState.progress[currentGameId];
                const updateStatsWrapper = (score, time) => handleUpdateStats(currentGameId, score, time);

                return (
                    <div className="w-full h-full flex flex-col font-kanit relative">
                        {/* Session Header */}
                        <div className="bg-emerald-600 text-white p-4 flex justify-between items-center shadow-md z-50 relative">
                            <button onClick={exitSession} className="bg-emerald-700/50 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-all active:scale-95 border border-emerald-500/30">
                                <Icon path={Icons.Home} size={20} />
                                <span className="text-sm font-bold">‡∏≠‡∏≠‡∏Å</span>
                            </button>
                            <div className="font-bold text-lg">‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà {activeGameIndex + 1}/3 : {gameData.name}</div>
                            <div className="w-16"></div> {/* Spacer for balance */}
                        </div>

                        {/* Game Component */}
                        <div className="flex-1 relative overflow-hidden z-0">
                            {currentGameId === 'memory' && <MemoryGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} updateStats={updateStatsWrapper} />}
                            {currentGameId === 'visuospatial' && <VisuospatialGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} updateStats={updateStatsWrapper} />}
                            {currentGameId === 'attention' && <AttentionGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} updateStats={updateStatsWrapper} />}
                            {currentGameId === 'language' && <LanguageGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} updateStats={updateStatsWrapper} />}
                            {currentGameId === 'executive' && <ExecutiveGame level={currentLevel} onComplete={handleLevelComplete} onExit={exitSession} updateStats={updateStatsWrapper} />}
                        </div>

                        {/* Custom Exit Modal */}
                        {showExitConfirm && (
                            <div className="absolute inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center p-6 animate-fade-in">
                                <div className="bg-white rounded-3xl p-8 w-full max-w-xs text-center shadow-2xl animate-pop-in">
                                    <div className="text-6xl mb-4">üè†</div>
                                    <h2 className="text-2xl font-black text-slate-800 mb-2">‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°?</h2>
                                    <p className="text-slate-500 mb-8">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏î‡πà‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>
                                    <div className="flex flex-col gap-3">
                                        <button onClick={confirmExitSession} className="w-full bg-red-500 hover:bg-red-600 text-white py-3 rounded-xl font-bold text-lg shadow-lg active:scale-95 transition">
                                            ‡πÉ‡∏ä‡πà, ‡∏≠‡∏≠‡∏Å‡πÄ‡∏•‡∏¢
                                        </button>
                                        <button onClick={() => setShowExitConfirm(false)} className="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 py-3 rounded-xl font-bold text-lg active:scale-95 transition">
                                            ‡πÑ‡∏°‡πà, ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // Selection Screen
            return (
                <div className="w-full h-full flex flex-col bg-emerald-50 font-kanit overflow-hidden">
                    <header className="pt-8 pb-4 px-6 bg-white rounded-b-[2.5rem] shadow-sm z-10 relative">
                        <button
                            onClick={() => setScreen('welcome')}
                            className="absolute top-6 left-4 p-2 rounded-full hover:bg-slate-100 text-slate-400 hover:text-slate-600 transition"
                        >
                            <Icon path={Icons.ArrowLeft} size={24} />
                        </button>
                        <div className="text-center mt-1">
                            <h1 className="text-3xl font-black text-emerald-800 mb-1">Zoo Brain Fit</h1>
                            <p className="text-slate-500 text-sm">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 3 ‡∏´‡∏°‡∏ß‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ù‡∏∂‡∏Å‡∏™‡∏°‡∏≠‡∏á</p>
                        </div>
                    </header>

                    <main className="flex-1 overflow-y-auto p-6 space-y-4 no-scrollbar">
                        {Object.values(GAMES).map(game => {
                            const isSelected = selectedGames.includes(game.id);
                            const currentLv = gameState.progress[game.id];
                            const highScore = gameState.highScores[game.id];
                            const timeMins = Math.floor(gameState.playTime[game.id] / 60);

                            return (
                                <div key={game.id}
                                    onClick={() => toggleSelection(game.id)}
                                    className={`relative p-4 rounded-3xl border-2 transition-all cursor-pointer flex items-center gap-4 shadow-sm active:scale-95
                                        ${isSelected ? 'border-emerald-500 bg-emerald-100 ring-2 ring-emerald-200' : 'border-white bg-white hover:border-emerald-200'}
                                     `}
                                >
                                    {/* Selection Indicator */}
                                    <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center shrink-0
                                        ${isSelected ? 'bg-emerald-500 border-emerald-500' : 'border-slate-200 bg-slate-50'}
                                    `}>
                                        {isSelected && <Icon path={Icons.Check} size={14} className="text-white" />}
                                    </div>

                                    {/* Icon */}
                                    <div className={`w-14 h-14 rounded-2xl flex items-center justify-center text-3xl shrink-0 ${game.color.replace('text-', 'bg-').split(' ')[0]}`}>
                                        {game.icon}
                                    </div>

                                    {/* Info */}
                                    <div className="flex-1">
                                        <h3 className="font-bold text-slate-800 text-lg">{game.name}</h3>
                                        <p className="text-slate-400 text-xs">{game.desc}</p>
                                        <div className="flex gap-2 mt-1">
                                            <span className="text-[10px] bg-yellow-100 text-yellow-700 px-1.5 py-0.5 rounded">üèÜ {highScore}</span>
                                            <span className="text-[10px] bg-blue-100 text-blue-700 px-1.5 py-0.5 rounded">‚è≥ {timeMins}m</span>
                                        </div>
                                    </div>

                                    {/* Level & Reset */}
                                    <div className="flex flex-col items-end gap-2">
                                        <span className="text-xs font-bold bg-slate-100 text-slate-600 px-2 py-1 rounded-lg">
                                            Lv. {currentLv}
                                        </span>
                                        <button
                                            onClick={(e) => resetProgress(game.id, e)}
                                            className="p-2 text-slate-300 hover:text-red-400 hover:bg-red-50 rounded-full transition"
                                        >
                                            <Icon path={Icons.Trash} size={16} />
                                        </button>
                                    </div>
                                </div>
                            );
                        })}
                        <div className="h-20"></div>
                    </main>

                    {/* Footer / Start Button */}
                    <div className="absolute bottom-0 w-full p-6 bg-gradient-to-t from-white via-white/90 to-transparent pointer-events-none flex justify-center">
                        <button
                            onClick={startSession}
                            disabled={selectedGames.length !== 3}
                            className={`w-full max-w-sm py-4 rounded-2xl font-black text-xl shadow-xl flex items-center justify-center gap-2 pointer-events-auto transition-all
                                ${selectedGames.length === 3
                                    ? 'bg-emerald-600 text-white hover:bg-emerald-700 hover:scale-105 active:scale-95'
                                    : 'bg-slate-200 text-slate-400 cursor-not-allowed'}
                            `}
                        >
                            {selectedGames.length === 3 ? (
                                <><span>üöÄ</span> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô!</>
                            ) : (
                                <span>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏µ‡∏Å {3 - selectedGames.length} ‡∏´‡∏°‡∏ß‡∏î</span>
                            )}
                        </button>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>